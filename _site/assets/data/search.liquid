


[ { "title" : "Nmap介紹 (1)", "category" : "", "tags" : " Cybersecurity", "url" : "/demo/2025/05/03/Nmap-1.html", "date" : "May 3, 2025", "excerpt" : "Intro 本篇介紹Nmap這個強大的滲透測試工具，常見的功能有： Live Host Discovery(在線主機搜索) Port Scan (端口搜索) Firewall Detection (測試目標主機防火牆設置)在使用Nmap時，通常是先利用在線主機搜索，得出所有在線主機；然後再利用端口搜索去進一步搜尋開放的端口及端口上運行的服務。通過這樣的實現才不會在離線主機上進行不必要的端口搜索浪費時間。另外關於測試目標主機防火...", "content" : "Intro 本篇介紹Nmap這個強大的滲透測試工具，常見的功能有： Live Host Discovery(在線主機搜索) Port Scan (端口搜索) Firewall Detection (測試目標主機防火牆設置)在使用Nmap時，通常是先利用在線主機搜索，得出所有在線主機；然後再利用端口搜索去進一步搜尋開放的端口及端口上運行的服務。通過這樣的實現才不會在離線主機上進行不必要的端口搜索浪費時間。另外關於測試目標主機防火牆設置是通過幾種巧妙的方式來檢測目標主機是否有防火牆設置，這後面會提到，算是Nmap工具功能的延伸。 Host Discovery using ARP nmap -PR -sn TARGET -sn 的意思是不要做端口掃描，因為目前只想要做在線主機搜索 -PR 是告訴nmap使用ARP scan。同時請注意使用 -PR 需要有root權限(原因是ARP屬於Data Link Layer，需要自己構造raw packet。而這一步因為系統安全考慮需要有root權限) 另外這種在線主機查詢的方法只適用於在同一個Subnet中才有效果(原因也很簡單，因為ARP packet只會在同一個Subnet中廣播，沒辦法透過Router傳遞到其他的Subnet，所以這種策略只適用於目標主機段與你處於同一個Subnet) 但如果你指定了 -sn 的情況下與目標主機段處於不同個 Subnet 的話，nmap 會自動將查詢策略轉為使用混合策略： ICMP echo requests, TCP ACK to port 80, TCP SYN to port 443, ICMP timestamp request. 例子： sudo nmap -PR -sn 10.10.210.1/24 Host Discovery using ICMP nmap -PE -sn TARGETnmap -PP -sn TARGETnmap -PM -sn TARGET 這三種利用ICMP的檢測方式皆不需要root權限，因為ICMP不需要動到raw packet(ICMP基於IP層) 這三種策略都可以支持自己與目標主機段處於不同 Subnet，因為ICMP協議是基於IP協議之上(將整個IP packet包裝為payload)，所以可以將這些ICMP packet傳送到不同 Subnet 來查詢 -PE 是告訴nmap使用 ICMP Echo Request -PP 是告訴nmap使用 ICMP Timestamp Request -PM 是告訴nmap使用 ICMP Address Mask Request 例子： sudo nmap -PE -sn 10.10.210.1/24sudo nmap -PP -sn 10.10.210.1/24sudo nmap -PM -sn 10.10.210.1/24 Host Discovery using TCP nmap -PS -sn TARGETnmap -PA -sn TARGETnmap -PU -sn TARGET 這三種利用TCP/UDP的檢測方式皆不需要root權限，因為它們也不需要動到raw packet(TCP/UDP基於IP層) 這三種策略都可以支持自己與目標主機段處於不同 Subnet，因為TCP/UDP協議是基於IP協議之上(將整個IP packet包裝為payload)，所以可以將這些TCP/UDP packet傳送到不同 Subnet 來查詢 -PS 是告訴nmap傳送 TCP SYN，等待 TCP SYN-ACK，並傳回 TCP ACK -PA 是告訴nmap傳送 TCP ACK，並等待 TCP RST (因為target主機會覺得很奇怪，明明都沒有建立tcp連接就收到ACK，所以直接傳回一個RST來回絕這個ACK) -PU 是告訴nmap傳送 UDP packet 關於 -PU 我們必須要知道，由於UDP是無狀態的協議(代表說即使目標主機接收到我們傳送的UDP packet，也不會有回覆)，因此我們判斷的條件要與TCP/ICMP反著來。也就是說，TCP/ICMP大多是由接收到回覆包來判斷目標主機是否在線；而UDP則是藉由接收到回覆包來知道目標主機離線。因此在 -PU 這種策略下，若是接收到回覆的話有兩種可能： ICMP(3,3) Port Unreachable: 代表目標主機可能在線，只不過端口關閉 ICMP(3,1) Host Unreachable: 代表目標主機離線 最後，如果在timeout過後沒有收到回覆，就代表說目標主機有可能在線 例子： sudo nmap -PS -sn 10.10.210.1/24sudo nmap -PA -sn 10.10.210.1/24sudo nmap -PU -sn 10.10.210.1/24 學習資料 TryHackMe CompTIA Pentest+ / Information Gathering and Vulnerability Scanning / Nmap Live Host Discovery Nmap Host Discovery" }, { "title" : "Passive Reconnaissance (1)", "category" : "", "tags" : " Cybersecurity", "url" : "/demo/2025/04/30/Passive-Reconnaissance-1.html", "date" : "April 30, 2025", "excerpt" : "Intro 本篇來介紹幾個常用的Passive Reconnaissance工具來供大家參考，並提供相關的背景知識和基本使用方法，其中包含： whois nslookup dig DNSDumpster Shodan而介紹工具前必須先瞭解此工具的用處、背景再來才是工具的基本用法，這樣才能理解透徹並善加使用 whois 用處： 查看此domain註冊時提...", "content" : "Intro 本篇來介紹幾個常用的Passive Reconnaissance工具來供大家參考，並提供相關的背景知識和基本使用方法，其中包含： whois nslookup dig DNSDumpster Shodan而介紹工具前必須先瞭解此工具的用處、背景再來才是工具的基本用法，這樣才能理解透徹並善加使用 whois 用處： 查看此domain註冊時提供的信息，注意，由於安全意識抬頭且此工具被大家熟知，故而可以在此紀錄上做手腳，因此用此工具獲得的資訊必須妥善使用 背景知識： 每一位開發者/公司在向Registrar註冊網域名稱時都會提供相應資訊，如公司註冊人、電話、郵箱等。Registrar再向Whois Server提供資料已作後續查詢或其他用途。而我們使用的whois工具中查詢的便是多個Whois server組成的集合 基本使用： whois google.com nslookup 用處： 它可以幫助你確認一個網域名稱對應的 IP 地址、DNS 記錄的內容、以及測試 DNS 是否正確運作 背景知識： 首先要先瞭解DNS是什麼? The Domain Name System (DNS) is a hierarchical and distributed name service that provides a naming system for computers, services, and other resources on the Internet or other Internet Protocol (IP) networks 簡單來說，DNS就是幫你把google.com轉換成ipv4或ipv6的地址。DNS Server就是儲存這個對照關係的數據庫，被每個Registrar保存並用於在有人使用網域名稱是給予對照的地址。值得一提的是，這個數據庫中存著的數據對照關係不單單只是前面提到的網域名稱對映ipv4/ipv6地址，以下是多個 DNS Record： - A: 網域名稱-&amp;gt;IPv4 - AAAA: 網域名稱-&amp;gt;IPv6 - CNAME: 網域別名-&amp;gt;網域名稱 - MX: 網域名稱-&amp;gt;Mail Server - TXT: 儲存任意資料 - SOA: 此域名設置 基本使用：nslookup OPTIONS DOMAIN_NAME SERVER OPTIONS(要查詢的DNS Record類別) -type=ADOMAIN_NAME(要查詢的域名) google.comSERVER(可選，要指定查詢的DNS Server) 1.1.1.1nslookup -type=A google.com 1.1.1.1nslookup -type=MX google.com dig(Domain Information Groper) 用處： 與nslookup使用場景基本類似，但提供更多資訊 基本使用：dig @SERVER DOMAIN_NAME TYPE SERVER(可選，要指定查詢的DNS Server) 1.1.1.1DOMAIN_NAME(要查詢的域名) google.comTYPE(要查詢的DNS Record類別) TXTdig google.com TXTdig @1.1.1.1 google.com MX DNSDumpster 用處： 是一個網站工具，可以通過瀏覽器使用非常方便。他與 nslookup 和 dig 工具不同的地方是， DNSDumpster 可以查詢到子域名，例如你查詢 google.com 可以搜尋到 admin.google.com 等等子域名，對於要搜集有關網域資料的人來說非常有用 基本使用：直接打開瀏覽器搜尋 DNSDumpster 或直接點擊連結即可。搜尋容易功能強大，就是免費版對結果數量有限制，沒辦法查找到最完全的資訊(但也非常夠用) Shodan 用處： 是一個更加強大且全面的網站工具，它注重的是所有與網路連接的設備檢測（包含IoT等），故而非常強大。也可用在DNS搜索、OS/Server版本型號檢測等。Shodan 比較像是查看統計數據的工具，以及該連接設備的詳細資料，而並非只著重在DNS Query 基本使用：直接打開瀏覽器搜尋 Shodan 或直接點擊連結即可。可以搜尋域名 google.com、OS版本 Ubuntu、Server版本 Apache/2.4.18等等，功能非常全面 學習資料 TryHackMe CompTIA Pentest+ / Information Gathering and Vulnerability ScanningPassive Reconnaissance DNSDumpster Shodan" }, { "title" : "LeetCode 4.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/28/LeetCode-4.html", "date" : "June 28, 2024", "excerpt" : "QuestionGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).Example Example 1: Input: nums1 = [1,3], nums2 = [2] Out...", "content" : "QuestionGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).Example Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.0 Example 2: Input: [1,2], nums2 = [3,4] Output: 2.5 Complexity Time complexity: O(log(m+n)) Space complexity: O(1) Codeclass Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int left = 0, right = 0; double result = 0; if ((nums1.length + nums2.length) % 2 == 0) { int mid2 = (nums1.length+nums2.length)/2; int mid1 = mid2 - 1; boolean isMid1 = false, isMid2 = false; while (left &amp;lt; nums1.length &amp;amp;&amp;amp; right &amp;lt; nums2.length) { if (left + right == mid1) { result += nums1[left] &amp;lt;= nums2[right] ? nums1[left] : nums2[right]; isMid1 = true; }else if (left + right == mid2) { result += nums1[left] &amp;lt;= nums2[right] ? nums1[left] : nums2[right]; isMid2 = true; break; } if (nums1[left] &amp;lt;= nums2[right]) { left++; }else{ right++; } } if (!isMid1 &amp;amp;&amp;amp; !isMid2) { int pos1 = left == nums1.length ? mid1 - left : mid1 - right; int pos2 = pos1 + 1; result += left == nums1.length ? nums2[pos1] : nums1[pos1]; result += left == nums1.length ? nums2[pos2] : nums1[pos2]; }else if (isMid1 &amp;amp;&amp;amp; !isMid2) { int pos2 = left == nums1.length ? mid2 - left : mid2 - right; result += left == nums1.length ? nums2[pos2] : nums1[pos2]; } return result /= 2; }else{ int mid = (nums1.length + nums2.length) / 2; while (left &amp;lt; nums1.length &amp;amp;&amp;amp; right &amp;lt; nums2.length) { if (left + right == mid) return nums1[left] &amp;lt;= nums2[right] ? nums1[left] : nums2[right]; if (nums1[left] &amp;lt;= nums2[right]) { left++; }else{ right++; } } int pos = left == nums1.length ? mid - left : mid - right; return left == nums1.length ? nums2[pos]: nums1[pos]; } }}Check out the description of this problem at LC 4." }, { "title" : "LeetCode 474.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/28/LeetCode-474.html", "date" : "June 28, 2024", "excerpt" : "QuestionYou are given an array of binary strings strs and two integers m and n.Return the size of the largest subset of strs such that there are at most m 0&amp;#39;s and n 1&amp;#39;s in the subset.A set x is a subset of a set y if all elements of x are ...", "content" : "QuestionYou are given an array of binary strings strs and two integers m and n.Return the size of the largest subset of strs such that there are at most m 0&#39;s and n 1&#39;s in the subset.A set x is a subset of a set y if all elements of x are also elements of y.Example Example 1: Input: strs = [“10”,”0001”,”111001”,”1”,”0”], m = 5, n = 3 Output: 4 Explanation: The largest subset with at most 5 0’s and 3 1’s is {“10”, “0001”, “1”, “0”}, so the answer is 4.Other valid but smaller subsets include {“0001”, “1”} and {“10”, “1”, “0”}.{“111001”} is an invalid subset because it contains 4 1’s, greater than the maximum of 3. Example 2: Input: strs = [“10”,”0”,”1”], m = 1, n = 1 Output: 2 Explanation: The largest subset is {“0”, “1”}, so the answer is 2. Complexity Time complexity: O(mnlen(strs)) Space complexity: O(mnlen(strs)) Codeclass Solution { public int findMaxForm(String[] strs, int m, int n) { int[][][] dp = new int[strs.length + 1][m + 1][n + 1]; int oneCount = 0; int zeroCount = 0; for(int i = 1; i &amp;lt; strs.length + 1; ++i) { String str = strs[i - 1]; int[] count = count(str); zeroCount += count[0]; oneCount += count[1]; for(int j = 0; j &amp;lt; m + 1; ++j) { for(int k = 0; k &amp;lt; n + 1; ++k) { if (j == 0 &amp;amp;&amp;amp; k == 0) { dp[i][j][k] = 0; } else if (zeroCount &amp;lt;= j &amp;amp;&amp;amp; oneCount &amp;lt;= k) { dp[i][j][k] = i; } else if (j &amp;gt;= count[0] &amp;amp;&amp;amp; k &amp;gt;= count[1]){ dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - count[0]][k - count[1]] + 1); } else { dp[i][j][k] = dp[i - 1][j][k]; } } } } return dp[strs.length][m][n]; } public int[] count(String str) { int[] res = new int[2]; for (char c : str.toCharArray()) { if (c == &#39;0&#39;) res[0]++; else res[1]++; } return res; }}Check out the description of this problem at LC 474." }, { "title" : "LeetCode 467.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/28/LeetCode-467.html", "date" : "June 28, 2024", "excerpt" : "QuestionWe define the string base to be the infinite wraparound string of &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;, so base will look like this:&amp;quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&amp;quot;.Given a string s, return the...", "content" : "QuestionWe define the string base to be the infinite wraparound string of &quot;abcdefghijklmnopqrstuvwxyz&quot;, so base will look like this:&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;.Given a string s, return the number of unique non-empty substrings of s are present in base.Complexity Time complexity: O(n^2) Space complexity: O(n^2) Code 1(TLE)class Solution { public int findSubstringInWraproundString(String s) { int n = s.length(); boolean[][] isqualified = new boolean[n][n]; Set&amp;lt;String&amp;gt; uni = new HashSet&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;n; i++) { isqualified[i][i] = true; if (!uni.contains(String.valueOf(s.charAt(i)))) { uni.add(String.valueOf(s.charAt(i))); } } for (int len=2; len&amp;lt;=n; len++) { for (int i=0; i&amp;lt;=n-len; i++) { String temp = s.substring(i, i + len); if (isqualified[i][i+len-2] &amp;amp;&amp;amp; isconsecutive(s.charAt(i + len - 2), s.charAt(i + len - 1))) { isqualified[i][i+len-1] = true; uni.add(temp); } } } return uni.size(); } public boolean isconsecutive(char former, char later) { if (later == &#39;a&#39; &amp;amp;&amp;amp; former == &#39;z&#39;) return true; else return later - former == 1; }}Complexity Time complexity: O(n) Space complexity: O(n) Code 2class Solution { public int findSubstringInWraproundString(String s) { int dp[] = new int[s.length()]; dp[s.length() - 1] = 1; int maxArray[] = new int[26]; maxArray[s.charAt(s.length()-1) - &#39;a&#39;] = 1; for(int i = s.length() - 2 ; i &amp;gt;= 0 ; i--){ if(s.charAt(i) == s.charAt(i+1) - 1 || s.charAt(i) == &#39;z&#39; &amp;amp;&amp;amp; s.charAt(i+1) == &#39;a&#39;){ dp[i] = 1 + dp[i+1]; }else{ dp[i] = 1; } int key = s.charAt(i) - &#39;a&#39;; maxArray[key] = Math.max(maxArray[key],dp[i]); } int res = 0; for(int i=0;i&amp;lt;26;i++){ res = res + maxArray[i]; } return res; }}Check out the description of this problem at LC 467." }, { "title" : "LeetCode 464.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/28/LeetCode-464.html", "date" : "June 28, 2024", "excerpt" : "Complexity Time complexity: O(2^n) Space complexity: O(2^n) Codeclass Solution { public boolean canIWin(int maxChoosableInteger, int desiredTotal) { // First of all, we check if it&amp;#39;s even possible for our players to reac...", "content" : "Complexity Time complexity: O(2^n) Space complexity: O(2^n) Codeclass Solution { public boolean canIWin(int maxChoosableInteger, int desiredTotal) { // First of all, we check if it&#39;s even possible for our players to reach the disiredTotal int totalPossibleSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2; if (totalPossibleSum &amp;lt; desiredTotal) return false; // Declare a map for memoization, where the key is the bitmask of our current state (0 - number is available for use, 1 - number was taken) Map&amp;lt;Integer, Boolean&amp;gt; memo = new HashMap&amp;lt;&amp;gt;(); return dp(desiredTotal, 0, maxChoosableInteger, memo); } private boolean dp(int goal, int state, int maxChoosable, Map&amp;lt;Integer, Boolean&amp;gt; memo) { // If we have already calculated a result for this state, then return it if (memo.containsKey(state)) { return memo.get(state); } // Declare the result variable boolean result = false; // Iterate over all possible integers from 1 to maxChoosable for (int i = 1; i &amp;lt;= maxChoosable; i++) { // Then we have to check our state (bitmask) to see if our current integer (i) was used or not boolean isAvailable = (state &amp;gt;&amp;gt; i) % 2 == 0; // If it was used, then we keep looking for an unused integer if (!isAvailable) { continue; } // We check our win conditions. If we reach the goal, our result is true, and we can jump to our last lines. if (goal - i &amp;lt;= 0) { result = true; break; } // We need to create a new state (bitmask) to mark our current integer as used int currMask = 1 &amp;lt;&amp;lt; i; int newState = state | currMask; // And we pass the turn to our rival boolean rivalResult = dp(goal - i, newState, maxChoosable, memo); // In case our rival doesn&#39;t win, it means that it&#39;s possible for us to beat the rival if (!rivalResult) { result = true; break; } } // We save our result for the current state and return it memo.put(state, result); return result; }}Check out the description of this problem at LC 464." }, { "title" : "LeetCode 2285.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/28/LeetCode-2285.html", "date" : "June 28, 2024", "excerpt" : "Complexity Time complexity: O(len(roads)) Space complexity: O(n) Codeclass Solution { public long maximumImportance(int n, int[][] roads) { int[] times = new int[n]; for (int[] r: roads) { times[r[0]]++; ...", "content" : "Complexity Time complexity: O(len(roads)) Space complexity: O(n) Codeclass Solution { public long maximumImportance(int n, int[][] roads) { int[] times = new int[n]; for (int[] r: roads) { times[r[0]]++; times[r[1]]++; } int[] time = new int[roads.length + 1]; for (int t: times) { time[t]++; } int pointer = n; long result = 0; boolean flag = true; for (int i=roads.length; i&amp;gt;=0; i--) { if (time[i] &amp;gt; 0) { result += (2 * pointer - time[i] + 1) * (long) time[i] * (long) i / 2; pointer -= time[i]; } } return result; }}Check out the description of this problem at LC 2285." }, { "title" : "LeetCode 416.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-416.html", "date" : "June 27, 2024", "excerpt" : "Complexity Time complexity: O(n^2) Space complexity: O(n) Codeclass Solution { public boolean canPartition(int[] nums) { int half = 0; for (int n: nums) { half += n; } if (half % 2 != ...", "content" : "Complexity Time complexity: O(n^2) Space complexity: O(n) Codeclass Solution { public boolean canPartition(int[] nums) { int half = 0; for (int n: nums) { half += n; } if (half % 2 != 0) return false; half = half &amp;gt;&amp;gt; 1; boolean[] reach = new boolean[half + 1]; List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int num: nums) { for (int i=1; i&amp;lt;=half; i++) { if (reach[i] &amp;amp;&amp;amp; i + num &amp;lt;= half) { if (i + num == half) return true; tmp.add(i+num); } } if (num &amp;lt; half) reach[num] = true; else if (num == half) return true; else return false; for (Integer in: tmp) { reach[in] = true; } tmp.clear(); } return false; }}Check out the description of this problem at LC 416." }, { "title" : "LeetCode 413.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-413.html", "date" : "June 27, 2024", "excerpt" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public int numberOfArithmeticSlices(int[] nums) { int n = nums.length; boolean[][] isAri = new boolean[n][n]; for (boolean[] r: i...", "content" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public int numberOfArithmeticSlices(int[] nums) { int n = nums.length; boolean[][] isAri = new boolean[n][n]; for (boolean[] r: isAri) { Arrays.fill(r, false); } int count = 0; for (int i=0; i&amp;lt;=n-3; i++) { if (nums[i+1]-nums[i] == nums[i+2]-nums[i+1]) { isAri[i][i+2] = true; count++; } } for (int len=3; len&amp;lt;=n; len++) { for (int i=0; i&amp;lt;=n-len; i++) { if (isAri[i+1][i+len-1] &amp;amp;&amp;amp; nums[i+1]-nums[i] == nums[i+2]-nums[i+1]) { isAri[i][i+len-1] = true; count++; } } } return count; }}Check out the description of this problem at LC 413." }, { "title" : "LeetCode 396.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-396.html", "date" : "June 27, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int maxRotateFunction(int[] nums) { int prev = 0, sum = 0; for (int i=0; i&amp;amp;lt;nums.length; i++) { prev += nums[i] * i;...", "content" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int maxRotateFunction(int[] nums) { int prev = 0, sum = 0; for (int i=0; i&amp;lt;nums.length; i++) { prev += nums[i] * i; sum += nums[i]; } int result = Integer.MIN_VALUE; for (int i=1; i&amp;lt;=nums.length; i++) { prev += (sum - nums[nums.length - i] * nums.length); result = Math.max(result, prev); } return result; }}Check out the description of this problem at LC 396." }, { "title" : "LeetCode 376.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-376.html", "date" : "June 27, 2024", "excerpt" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public int wiggleMaxLength(int[] nums) { if (nums.length &amp;amp;lt; 2) return nums.length; int[][] result = new int[nums.length][2]; // re...", "content" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public int wiggleMaxLength(int[] nums) { if (nums.length &amp;lt; 2) return nums.length; int[][] result = new int[nums.length][2]; // result[i][0] will store the max length of wiggle sequence in range [0,i] //[][0] represents the max length whlie the last is a decreasing sequence //[][1] represents the max length whlie the last is a increasing sequence for (int[] r: result) { Arrays.fill(r, 1); } int max = 1; for (int i=0; i&amp;lt;nums.length; i++) { for (int j=0; j&amp;lt;i; j++) { if (nums[i] &amp;lt; nums[j]) { result[i][0] = Math.max(result[i][0], 1 + result[j][1]); }else if (nums[i] &amp;gt; nums[j]) { result[i][1] = Math.max(result[i][1], 1 + result[j][0]); } max = Math.max(max, Math.max(result[i][0], result[i][1])); } } return max; }}Check out the description of this problem at LC 376." }, { "title" : "LeetCode 375.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-375.html", "date" : "June 27, 2024", "excerpt" : "Complexity Time complexity: O(n^3) Space complexity: O(n^2) Codeclass Solution { public int getMoneyAmount(int n) { int[][] money = new int[n][n]; for (int[] m: money) { Arrays.fill(m, Integer.MAX_VALUE); ...", "content" : "Complexity Time complexity: O(n^3) Space complexity: O(n^2) Codeclass Solution { public int getMoneyAmount(int n) { int[][] money = new int[n][n]; for (int[] m: money) { Arrays.fill(m, Integer.MAX_VALUE); } for (int i=0; i&amp;lt;n; i++) { money[i][i] = 0; if (i + 1 &amp;lt; n) { money[i][i+1] = i + 1; } } for (int len=3; len&amp;lt;=n; len++) { for (int i=0; i&amp;lt;=n-len; i++) { for (int j=i; j&amp;lt;i+len; j++) { if (i == j) { money[i][i+len-1] = Math.min(money[i][i+len-1], (j+1) + money[j+1][i+len-1]); }else if (j == i + len - 1) { money[i][i+len-1] = Math.min(money[i][i+len-1], money[i][j-1] + (j+1)); }else{ money[i][i+len-1] = Math.min(money[i][i+len-1], (j+1) + Math.max(money[i][j-1], money[j+1][i+len-1])); } } } } return money[0][n-1]; }}Check out the description of this problem at LC 375." }, { "title" : "Dynamic Programming", "category" : "", "tags" : " Algorithm", "url" : "/demo/2024/06/27/Dynamic-Programming.html", "date" : "June 27, 2024", "excerpt" : "Problems LeetCode 375. Guess Number Higher or Lower II LeetCode 376. Wiggle Subsequence LeetCode 396. Rotate Function LeetCode 413. Arithmetic Slices LeetCode 416. Partition Equal Subset Sum LeetCode 464. Can I win LeetCode 467. Unique Subs...", "content" : "Problems LeetCode 375. Guess Number Higher or Lower II LeetCode 376. Wiggle Subsequence LeetCode 396. Rotate Function LeetCode 413. Arithmetic Slices LeetCode 416. Partition Equal Subset Sum LeetCode 464. Can I win LeetCode 467. Unique Substrings in Wraparound String LeetCode 474. Ones and Zeros" }, { "title" : "LeetCode 96.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/27/LeetCode-96.html", "date" : "June 27, 2024", "excerpt" : "QuestionGiven an integer n, return the number of structurally unique BST&amp;#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n.Example Example 1: Input: n = 3 Output: 5 Example 2: Input: ...", "content" : "QuestionGiven an integer n, return the number of structurally unique BST&#39;s (binary search trees) which has exactly n nodes of unique values from 1 to n.Example Example 1: Input: n = 3 Output: 5 Example 2: Input: n = 1 Output: 1 IntuitionAs I saw this question, I was wondering if I can breakdown this problem into sub-problems.Every BST, or in general Tree, must have its left and right node(sub-tree) whatever they’re empty.Obviously from the description we can tell that the answer should be the multiplication of the permutation of left and right sub-tree.Additionally, we can assume whatever nodes’ value are, if they are unique then the answer should be the same if two of trees have same number of nodes.For instance, both TreeA[1,2,5] and TreeB[2,3,6] has the answer 5.Approach Declare an array to keep the answer: result[n + 1] Set initial value of the array: result[0] = 1, result[1] = 1, result[2] = 2 Do the iteration from bottom to top because Tree[i] will use Tree[i-1] to Tree[1]Complexity Time complexity: O(n^2) Space complexity: O(n) Codeclass Solution { public static int numTrees(int n) { if (n == 1) return 1; int[] result = new int[n + 1]; Arrays.fill(result, 1); result[2] = 2; // initial value for (int i=3; i&amp;lt;=n; i++) { int temp = 0; for (int j=0; j&amp;lt;i; j++) { // // minus one because the root node counts temp += result[j] * result[i - j - 1]; } result[i] = temp; } return result[n]; }}Check out the description of this problem at LC 96." }, { "title" : "LeetCode 279.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-279.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(nsqrt(n))* Space complexity: O(n) Codeclass Solution { public int numSquares(int n) { int[] dp = new int[10001]; Arrays.fill(dp, 10000); dp[0] = 0; for (int i=1; i&amp;amp;lt;=n...", "content" : "Complexity Time complexity: O(nsqrt(n))* Space complexity: O(n) Codeclass Solution { public int numSquares(int n) { int[] dp = new int[10001]; Arrays.fill(dp, 10000); dp[0] = 0; for (int i=1; i&amp;lt;=n; i++) { for (int j=1; j*j &amp;lt;= i; j++) { dp[i] = Math.min(dp[i], dp[i - j*j] + 1); } } return dp[n]; }}Check out the description of this problem at LC 279." }, { "title" : "LeetCode 57.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-57.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List&amp;amp;lt;int[]&amp;amp;gt;list=new ArrayList&amp;amp;lt;&amp;amp;gt;(); int i=0; ...", "content" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List&amp;lt;int[]&amp;gt;list=new ArrayList&amp;lt;&amp;gt;(); int i=0; while(i &amp;lt; intervals.length &amp;amp;&amp;amp; intervals[i][1] &amp;lt; newInterval[0]){ list.add(intervals[i++]); } while(i &amp;lt; intervals.length &amp;amp;&amp;amp; intervals[i][0] &amp;lt;= newInterval[1]){ newInterval[0]=Math.min(intervals[i][0],newInterval[0]); newInterval[1]=Math.max(intervals[i][1],newInterval[1]); i++; } list.add(newInterval); while(i &amp;lt; intervals.length){ list.add(intervals[i++]); } return list.toArray(new int[list.size()][]); }}Check out the description of this problem at LC 57." }, { "title" : "LeetCode 56.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-56.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(nlogn) Space complexity: O(n) Codeclass Solution { public int[][] merge(int[][] intervals) { List&amp;amp;lt;int[]&amp;amp;gt; result = new ArrayList&amp;amp;lt;&amp;amp;gt;(); Arrays.sort(intervals, Com...", "content" : "Complexity Time complexity: O(nlogn) Space complexity: O(n) Codeclass Solution { public int[][] merge(int[][] intervals) { List&amp;lt;int[]&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[0])); //nlogn int start = intervals[0][0], end = intervals[0][1]; for (int i=1; i&amp;lt;intervals.length; i++) { if (intervals[i][0] &amp;lt;= end &amp;amp;&amp;amp; intervals[i][1] &amp;gt; end) { end = intervals[i][1]; }else if (intervals[i][0] &amp;gt; end) { result.add(new int[]{start, end}); start = intervals[i][0]; end = intervals[i][1]; } } return result.toArray(new int[result.size()][]); }}Check out the description of this problem at LC 56." }, { "title" : "LeetCode 289.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-289.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public void gameOfLife(int[][] board) { // just consider which cells would live in next gen boolean[][] live = new boolean[board.length]...", "content" : "Complexity Time complexity: O(n^2) Space complexity: O(n^2) Codeclass Solution { public void gameOfLife(int[][] board) { // just consider which cells would live in next gen boolean[][] live = new boolean[board.length][board[0].length]; for (int i=0; i&amp;lt;board.length; i++) { for (int j=0; j&amp;lt;board[0].length; j++) { int result = liveCount(board, i, j); if ((board[i][j] == 1 &amp;amp;&amp;amp; (result == 2 || result == 3)) || (board[i][j] == 0 &amp;amp;&amp;amp; result == 3)) { live[i][j] = true; } } } for (int i=0; i&amp;lt;board.length; i++) { for (int j=0; j&amp;lt;board[0].length; j++) { if (live[i][j]) board[i][j] = 1; else board[i][j] = 0; } } } public int liveCount(int[][] board, int x, int y) { return isLive(board, x-1, y-1)+isLive(board, x-1, y)+isLive(board, x-1, y+1)+ isLive(board, x, y-1)+isLive(board, x, y+1)+ isLive(board, x+1, y-1)+isLive(board, x+1, y)+isLive(board, x+1, y+1); } public int isLive(int[][] board, int x, int y) { if (x &amp;lt; 0 || x &amp;gt;= board.length || y &amp;lt; 0 || y &amp;gt;= board[0].length) return 0; return board[x][y]; }}Check out the description of this problem at LC 289." }, { "title" : "LeetCode 48.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-48.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(n^2) Space complexity: O(n) Codeclass Solution { public void rotate(int[][] matrix) { int layer = 0; int n = matrix.length; int value = 0; int[] values = new int[n]; ...", "content" : "Complexity Time complexity: O(n^2) Space complexity: O(n) Codeclass Solution { public void rotate(int[][] matrix) { int layer = 0; int n = matrix.length; int value = 0; int[] values = new int[n]; while (layer &amp;lt; n/2) { for (int i=layer; i&amp;lt;n-1-layer; i++) { //top to right values[i] = matrix[i][n-1-layer]; matrix[i][n-1-layer] = matrix[layer][i]; } for (int i=layer; i&amp;lt;n-1-layer; i++) {//right to bottom value = values[i]; values[i] = matrix[n-1-layer][n-1-i]; matrix[n-1-layer][n-1-i] = value; } for (int i=layer; i&amp;lt;n-1-layer; i++) {//bottom to left value = values[i]; values[i] = matrix[n-1-i][layer]; matrix[n-1-i][layer] = value; } for (int i=layer; i&amp;lt;n-1-layer; i++) {//left to top value = values[i]; matrix[layer][i] = value; } layer++; } }}Check out the description of this problem at LC 48." }, { "title" : "LeetCode 54.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-54.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public List&amp;amp;lt;Integer&amp;amp;gt; spiralOrder(int[][] matrix) { List&amp;amp;lt;Integer&amp;amp;gt; result = new ArrayList&amp;amp;lt;Integer&amp;amp;gt;(); ...", "content" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); int width = matrix[0].length; int height = matrix.length; int countX = width, countY = height-1; int w = -1, h = 0; int flag = 1; // 1:right 2:down 3:left 4:up while (result.size() &amp;lt; height * width) { int count = 0; if (flag == 1) { //right w++; // move right: initial start point while (count &amp;lt; countX) { result.add(matrix[h][w + count]); count++; } countX--; w = w + countX; }else if (flag == 2) { //down h++; while (count &amp;lt; countY) { result.add(matrix[h + count][w]); count++; } countY--; h = h + countY; }else if (flag == 3) { //left w--; while (count &amp;lt; countX) { result.add(matrix[h][w - count]); count++; } countX--; w = w - countX; }else if (flag == 4) { //up h--; while (count &amp;lt; countY) { result.add(matrix[h - count][w]); count++; } countY--; h = h - countY; } if (++flag &amp;gt; 4) flag = 1; } return result; }}Check out the description of this problem at LC 54." }, { "title" : "LeetCode 1382.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/26/LeetCode-1382.html", "date" : "June 26, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public static class TreeNode { public int val; TreeNode left; TreeNode right; public TreeNode(){} public TreeNode(int v...", "content" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public static class TreeNode { public int val; TreeNode left; TreeNode right; public TreeNode(){} public TreeNode(int val) {this.val = val;} public TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left =left; this.right = right; } } public List&amp;lt;Integer&amp;gt; nodes = new ArrayList&amp;lt;Integer&amp;gt;(); public void traversal(TreeNode root) { if (root == null) return; traversal(root.left); nodes.add(root.val); traversal(root.right); } public TreeNode BST(int left, int right) { if (left &amp;gt; right) return null; int mid = left + (right - left) / 2; TreeNode current = new TreeNode(nodes.get(mid)); current.left = BST(left, mid - 1); current.right = BST(mid + 1, right); return current; } public TreeNode balanceBST(TreeNode root) { traversal(root); return BST(0, nodes.size() - 1); }}Check out the description of this problem at LC 1382." }, { "title" : "LeetCode 30.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/25/LeetCode-30.html", "date" : "June 25, 2024", "excerpt" : "QuestionYou are given a string s and an array of strings words. All the strings of words are of the same length.A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.For example, if words ...", "content" : "QuestionYou are given a string s and an array of strings words. All the strings of words are of the same length.A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.For example, if words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;], then &quot;abcdef&quot;, &quot;abefcd&quot;, &quot;cdabef&quot;, &quot;cdefab&quot;, &quot;efabcd&quot;, and &quot;efcdab&quot; are all concatenated strings. &quot;acdbef&quot; is not a concatenated string because it is not the concatenation of any permutation of words.Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.ExampleExample 1: Input: s = “barfoothefoobarman”, words = [“foo”,”bar”] Output: [0,9] Explanation: The substring starting at 0 is “barfoo”. It is the concatenation of [“bar”,”foo”] which is a permutation of words.The substring starting at 9 is “foobar”. It is the concatenation of [“foo”,”bar”] which is a permutation of words.Example 2: Input: s = “wordgoodgoodgoodbestword”, words = [“word”,”good”,”best”,”word”] Output: [] Explanation: There is no concatenated substring.Example 3: Input: s = “barfoofoobarthefoobarman”, words = [“bar”,”foo”,”the”] Output: [6,9,12] Explanation: The substring starting at 6 is “foobarthe”. It is the concatenation of [“foo”,”bar”,”the”].The substring starting at 9 is “barthefoo”. It is the concatenation of [“bar”,”the”,”foo”].The substring starting at 12 is “thefoobar”. It is the concatenation of [“the”,”foo”,”bar”].IntuitionEven I know this problem can be solved by Sliding Window, it’s complicated.The following is my trial and yours is probably better than this so just give it a look :DI first tried delcare an array to record which word in words had been visited and use Queue to record the index.However, this solution pass over 80% testcases but will be failed on duplicate words.Then, I tried use HashMap to keep the numbers of each word and use Queue to make sure FIFO.ApproachDelcare two variables to record temporary data: Queue: keep current consecutive included words in a sequence Map: keep usable number of words It comes in three sitautions: (1) If current portion is not the key in Map, clear the queue and reset the map (reset words we can use) (2) If current portion matches the key but the number is not enough, poll out the queue while the usable number added by one until enough (3) If current portion matches the key and the number is enough, add portion to the queue and the matched number minus oneAfterwards: (RESULT) If Queue size is equal to the length of array words, meaning the substring(multiple portion concatenated) is existed, record the result and poll out the queue once (because portion[1] to portion[n] is still qualified)Take Exmaple 1 to explain how my solution works: Input: s = “barfoothefoobarman”, words = [“foo”,”bar”] init: i=0, j=0, Queue=[], Map=[“foo”,”bar”]=&amp;gt;[1, 1], RESULT=[] i=0, j=3, portion=substring(0, 3)=”bar” =&amp;gt; (3) =&amp;gt; Queue=[“bar”], Map=[“foo”,”bar”]=&amp;gt;[1, 0] i=0, j=6, portion=substring(3, 6)=”foo” =&amp;gt; (3) =&amp;gt; Queue=[“bar”, “foo”], Map=[“foo”,”bar”]=&amp;gt;[0, 0] (RESULT) =&amp;gt; Queue=[“foo”], Map=[“foo”,”bar”]=&amp;gt;[0, 1], RESULT=[0] i=0, j=9, portion=substring(6, 9)=”the” =&amp;gt; (1) =&amp;gt; Queue=[], Map=[“foo”,”bar”]=&amp;gt;[1, 1] i=0, j=12, portion=substring(9, 12)=”foo” =&amp;gt; (3) =&amp;gt; Queue=[“foo”], Map=[“foo”,”bar”]=&amp;gt;[0, 1] i=0, j=15, portion=substring(12, 15)=”bar” =&amp;gt; (3) =&amp;gt; Queue=[“foo”, “bar”], Map=[“foo”,”bar”]=&amp;gt;[0, 0] (RESULT) =&amp;gt; Queue=[“bar”], Map=[“foo”,”bar”]=&amp;gt;[1, 0], RESULT=[0, 9] i=0, j=18, portion=substring(15, 18)=”man” =&amp;gt; (1) =&amp;gt; Queue=[], Map=[“foo”,”bar”]=&amp;gt;[1, 1] i=1, … Complexity Time complexity: O(wlen * slen) wlen: length of array words slen: length of s Space complexity: O(n)Codeclass Solution { public List&amp;lt;Integer&amp;gt; findSubstring(String s, String[] words) { int wlen = words[0].length(); Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;String, Integer&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; copy = new HashMap&amp;lt;String, Integer&amp;gt;(); for (String w: words) { if (map.containsKey(w)) { map.put(w, map.get(w) + 1); copy.put(w, copy.get(w) + 1); }else{ map.put(w, 1); copy.put(w, 1); } } List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;wlen; i++) { //wlen for (int j=i; j&amp;lt;=s.length()-wlen; j+=wlen) { //slen / wlen String portion = s.substring(j, j+wlen); int index = map.getOrDefault(portion, -1); if (index &amp;lt; 0) { queue.clear(); map.clear(); map.putAll(copy); continue; }else if (index == 0) { //consumed while (queue.size() &amp;gt; 0) { String back = queue.peek(); if (back.equals(portion)) { queue.poll(); queue.offer(portion); break; }else{ map.put(back, map.get(back) + 1); queue.poll(); } } continue; } // matched queue.offer(portion); map.put(portion, map.get(portion) - 1); if (queue.size() == words.length) { String back = queue.poll(); map.put(back, map.get(back) + 1); result.add(j - queue.size() * wlen); } } queue.clear(); map.clear(); map.putAll(copy); } return result; }}Check out the description of this problem at LC 30." }, { "title" : "Sliding Window", "category" : "", "tags" : " Algorithm", "url" : "/demo/2024/06/25/Sliding-Window.html", "date" : "June 25, 2024", "excerpt" : "Problems LeetCode 3. Longest Substring Without Repeating Characters LeetCode 209. Minimum Size Subarray Sum LeetCode 15. 3Sum LeetCode 30. Substring with Concatenation of All Words", "content" : "Problems LeetCode 3. Longest Substring Without Repeating Characters LeetCode 209. Minimum Size Subarray Sum LeetCode 15. 3Sum LeetCode 30. Substring with Concatenation of All Words" }, { "title" : "LeetCode 3.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/25/LeetCode-3.html", "date" : "June 25, 2024", "excerpt" : "QuestionGiven a string s, find the length of the longest substring without repeating characters.Example 1:Input: s = &amp;quot;abcabcbb&amp;quot;Output: 3Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.Complexity Time complexity: O(n...", "content" : "QuestionGiven a string s, find the length of the longest substring without repeating characters.Example 1:Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3.Complexity Time complexity: O(nlogn) Space complexity: O(n) Codeclass Solution { public int lengthOfLongestSubstring(String s) { boolean[] exist = new boolean[200]; //ascii int l = 0, r = 0; int ans = 0; while (r &amp;lt; s.length()) { int c = (int) s.charAt(r); while (l &amp;lt; r &amp;amp;&amp;amp; exist[c]) { exist[(int) s.charAt(l++)] = false; } exist[c] = true; ans = Math.max(ans, r - l + 1); r++; } return ans; }}Check out the description of this problem at LC 3." }, { "title" : "LeetCode 209.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/25/LeetCode-209.html", "date" : "June 25, 2024", "excerpt" : "QuestionGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.Example 1:Input: target = 7, nums ...", "content" : "QuestionGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.Example 1:Input: target = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.IntuitionOn first try, I use BS to locate the answer. The time complexity is O(nlogn)After that, I saw the sliding window tag and then I tried use it on this problem.Complexity Time complexity: O(nlogn) Space complexity: O(n) Code (BS)class Solution { public int minSubArrayLen(int target, int[] nums) { int left = 0, right = nums.length; while (left &amp;lt;= right) {// logn int mid = left + (right - left) / 2; int result = 0; for (int i=0; i&amp;lt;mid; i++) { result += nums[i]; } if (result &amp;gt;= target) { right = mid - 1; continue; } for (int i=mid; i&amp;lt;nums.length; i++) { //n result -= nums[i-mid]; result += nums[i]; if (result &amp;gt;= target) { break; } } if (result &amp;gt;= target) { right = mid - 1; }else{ left = mid + 1; } } return left &amp;gt; nums.length ? 0 : left; }}Complexity Time complexity: O(n) Space complexity: O(n) Code (Sliding Window)class Solution { public int minSubArrayLen(int target, int[] nums) { int l = 0, r = 0; int sum = 0, ans = 100001; while (r &amp;lt; nums.length) { sum += nums[r]; while (sum &amp;gt;= target) { ans = Math.min(ans, r - l + 1); sum -= nums[l]; l++; } r++; } return ans &amp;gt; nums.length ? 0 : ans; }}Check out the description of this problem at LC 209." }, { "title" : "LeetCode 15.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-15.html", "date" : "June 24, 2024", "excerpt" : "class Solution { public List&amp;amp;lt;List&amp;amp;lt;Integer&amp;amp;gt;&amp;amp;gt; threeSum(int[] nums) { Arrays.sort(nums); //nlogn List&amp;amp;lt;List&amp;amp;lt;Integer&amp;amp;gt;&amp;amp;gt; result = new ArrayList&amp;amp;lt;List&amp;amp;lt;Integer&amp;amp;gt;&amp;am...", "content" : "class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { Arrays.sort(nums); //nlogn List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); int current = 0; for (int i=0; i&amp;lt;nums.length; i++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; int left = i+1, right = nums.length-1; while (left &amp;lt; right) { current = nums[i] + nums[left] + nums[right]; if (current == 0) { List&amp;lt;Integer&amp;gt; l = new ArrayList&amp;lt;&amp;gt;(); l.add(nums[i]); l.add(nums[left]); l.add(nums[right]); result.add(l); left++; while (nums[left] == nums[left-1] &amp;amp;&amp;amp; left&amp;lt;right){ left++; } }else if (current &amp;lt; 0) { left++; }else{ right--; } } } return result; }}Check out the description of this problem at LC 15." }, { "title" : "LeetCode 11.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-11.html", "date" : "June 24, 2024", "excerpt" : "QuestionGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;amp;lt;= ...", "content" : "QuestionGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space.IntuitionThe answer is the maximum area of the container (width * Min(height[left], height[right]))The container must have two sides (left &amp;amp; right) so I try two pointers first.ApproachThe problem is: When should the left pointer move right and the right pointer move left?Here’s the rule: Compare the Area[i+1, j] and Area[i, j-1]. The width of them are equal so we should focus on their heights. Assume height[i], height[j], height[i+1], height[j-1] which 0 &amp;lt;= i &amp;lt; j &amp;lt; n If height[i] &amp;lt; height[j], Area[i,j] &amp;gt; Area[i,j-1] Otherwise, Area[i,j] &amp;gt; Area[i+1,j]Use the example to exmaplify: height = [1,8,6,2,5,4,8,3,7] i=0, j=8, height[0] &amp;lt; height[8] Area[0, 8] = Min(height[0], height[8]) * 8 = 1 * 8 = 8 Compare two sub-situations: Area[0,7] &amp;amp; Area[1,8]: Area[0,7] = Min(1, 3) * 7 = 7 (Maintaining the smaller height (height[0]) cause the result must be smaller than previous result) Area[1,8] = Min(8, 7) * 7 = 49 (The answer will be in this case) Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int maxArea(int[] height) { if (height.length == 1) return 0; int left = 0, right = height.length - 1; int max = -1; while (left &amp;lt; right) { max = Math.max(max, Math.min(height[left], height[right])*(right-left)); if (height[left] &amp;lt; height[right]) { left++; }else{ right--; } } return max; }}Check out the description of this problem at LC 11." }, { "title" : "LeetCode 167.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-167.html", "date" : "June 24, 2024", "excerpt" : "QuestionGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;amp;lt;= ...", "content" : "QuestionGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space.IntuitionFirst thought: Iterate the array and use BS to find another possible value.Second thought: Use two pointers to optimize time complexity from O(nlogn) to O(n)Complexity Time complexity: O(nlogn) Space complexity: O(1) Code 1class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length-1; int tar = 0, mid = 0; for (int i=0; i&amp;lt;numbers.length; i++) { tar = target - numbers[i]; while (left &amp;lt;= right) { mid = left + (right - left) / 2; if (i != mid &amp;amp;&amp;amp; numbers[mid] == tar) { return new int[]{i + 1, mid + 1}; } if (numbers[mid] &amp;gt; tar) { right = mid - 1; }else{ left = mid + 1; } } left = 0; right = numbers.length - 1; } return new int[]{-1, -1}; }}Complexity Time complexity: O(n) Space complexity: O(1) Code 2class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0; int right = numbers.length - 1; while (left &amp;lt; right) { int total = numbers[left] + numbers[right]; if (total == target) { return new int[]{left + 1, right + 1}; } else if (total &amp;gt; target) { right--; } else { left++; } } return new int[]{-1, -1}; }}Check out the description of this problem at LC 167." }, { "title" : "LeetCode 28.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-28.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int strStr(String haystack, String needle) { int left2Right = 10001, right2Left = 10001; int hlen = haystack.length(), nlen = needle....", "content" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int strStr(String haystack, String needle) { int left2Right = 10001, right2Left = 10001; int hlen = haystack.length(), nlen = needle.length(); boolean match = false; for (int i=0; i&amp;lt;hlen; i++) { if (haystack.charAt(i) == needle.charAt(0)) { match = true; for (int j=1; j&amp;lt;nlen; j++) { if (i+j &amp;gt;= hlen || haystack.charAt(i+j) != needle.charAt(j)) { match = false; i+=(j-1); break; } } if (match) { left2Right = i; break; } } } for (int i=hlen-1; i&amp;gt;=0; i--) { if (haystack.charAt(i) == needle.charAt(nlen-1)) { match = true; for (int j=1; j&amp;lt;nlen; j++) { if (i-j &amp;lt; 0 || haystack.charAt(i-j) != needle.charAt(nlen-1-j)) { match = false; i-=(j-1); break; } } if (match) { i-=(nlen-1); right2Left = i; } } } return Math.min(left2Right, right2Left) == 10001 ? -1 : Math.min(left2Right, right2Left); }}Check out the description of this problem at LC 28." }, { "title" : "LeetCode 6.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-6.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public String convert(String s, int numRows) { if (numRows == 1) return s; String[] rows = new String[numRows]; Arrays.fill(rows, &amp;qu...", "content" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public String convert(String s, int numRows) { if (numRows == 1) return s; String[] rows = new String[numRows]; Arrays.fill(rows, &quot;&quot;); int row = 0; boolean inc = true; for (int i=0; i&amp;lt;s.length(); i++) { rows[row] += s.charAt(i); if (inc &amp;amp;&amp;amp; ++row == numRows) { inc = false; row -= 2; }else if (!inc &amp;amp;&amp;amp; --row &amp;lt; 0){ inc = true; row = 1; } } StringBuffer result = new StringBuffer(); for (int i=0; i&amp;lt;numRows; i++) { result.append(rows[i]); } return result.toString(); }}Check out the description of this problem at LC 6." }, { "title" : "LeetCode 151.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-151.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public String reverseWords(String s) { int prev = -1; StringBuffer result = new StringBuffer(); for (int i=s.length()-1; i&amp;amp;gt;=0;...", "content" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public String reverseWords(String s) { int prev = -1; StringBuffer result = new StringBuffer(); for (int i=s.length()-1; i&amp;gt;=0; i--) { if (prev &amp;lt; 0 &amp;amp;&amp;amp; s.charAt(i) != &#39; &#39;) { prev = i; }else if (prev &amp;gt; 0 &amp;amp;&amp;amp; s.charAt(i) == &#39; &#39;) { result.append(s.substring(i + 1, prev + 1)).append(&quot; &quot;); prev = -1; } } if (prev &amp;gt;= 0) result.append(s.substring(0, prev + 1)); else result.deleteCharAt(result.length() - 1); return result.toString(); }}Check out the description of this problem at LC 151." }, { "title" : "LeetCode 14.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-14.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public String longestCommonPrefix(String[] strs) { String pre = strs[0]; int index = 0, len = pre.length(); for (int i=1; i&amp;amp;lt;st...", "content" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public String longestCommonPrefix(String[] strs) { String pre = strs[0]; int index = 0, len = pre.length(); for (int i=1; i&amp;lt;strs.length; i++) { len = Math.min(len, strs[i].length()); while (index &amp;lt; len) { if (pre.charAt(index) != strs[i].charAt(index)) break; index++; } if (index == 0) return &quot;&quot;; pre = pre.substring(0, index); len = index; index = 0; } return pre; }}Check out the description of this problem at LC 14." }, { "title" : "LeetCode 58.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-58.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int lengthOfLastWord(String s) { int ind = s.length(); int left = 0, right = -1; while (--ind &amp;amp;gt;= 0) { if (s....", "content" : "Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int lengthOfLastWord(String s) { int ind = s.length(); int left = 0, right = -1; while (--ind &amp;gt;= 0) { if (s.charAt(ind) != &#39; &#39;) { right = ind; break; } } ind = right; while (--ind &amp;gt;= 0) { if (s.charAt(ind) == &#39; &#39;) { left = ind + 1; break; } } return right - left + 1; }}Check out the description of this problem at LC 58." }, { "title" : "LeetCode 12.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/24/LeetCode-12.html", "date" : "June 24, 2024", "excerpt" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public String intToRoman(int num) { int[] nums = new int[]{1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 3...", "content" : "Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public String intToRoman(int num) { int[] nums = new int[]{1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}; String[] romans = new String[]{&quot;M&quot;, &quot;CM&quot;, &quot;DCCC&quot;, &quot;DCC&quot;, &quot;DC&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;CCC&quot;, &quot;CC&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;LXXX&quot;, &quot;LXX&quot;, &quot;LX&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;XXX&quot;, &quot;XX&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;VIII&quot;, &quot;VII&quot;, &quot;VI&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;III&quot;, &quot;II&quot;, &quot;I&quot;}; int index = 0; String result = &quot;&quot;; while (num &amp;gt; 0) { if (num &amp;lt; nums[index]) index++; else{ num -= nums[index]; result = result + romans[index]; } } return result; }}Check out the description of this problem at LC 12." }, { "title" : "LeetCode 134.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/21/LeetCode-134.html", "date" : "June 21, 2024", "excerpt" : "QuestionThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You b...", "content" : "QuestionThere are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.Given two integer arrays gas and cost, return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be uniqueComplexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public static int canCompleteCircuit(int[] gas, int[] cost) { int sGas = 0, sCost = 0, res = 0, total = 0; for (int i = 0; i &amp;lt; gas.length; i++) { sGas += gas[i]; sCost += cost[i]; } if (sGas &amp;lt; sCost) return -1; for (int i = 0; i &amp;lt; gas.length; i++) { total += gas[i] - cost[i]; if (total &amp;lt; 0) { total = 0; res = i + 1; } } return res; }}Check out the description of these two problems at LC 134." }, { "title" : "LeetCode 238.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/21/LeetCode-238.html", "date" : "June 21, 2024", "excerpt" : "QuestionGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write ...", "content" : "QuestionGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation.Intuitionanswer[i] = nums[0] * … * nums[i-1] * numx[i+1] * … * nums[n-1]ApproachDivide the product answer[i] by left[i-1] times right[i+1]: left[i-1] = nums[0] * nums[1] * … * nums[i-1] right[i+1] = nums[i+1] * nums[i+2] * … * nums[n-1]Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { public int[] productExceptSelf(int[] nums) { int[] left2Right = new int[nums.length]; // left2Right[i] = nums[0]*nums[1]*...*nums[i] int[] right2Left = new int[nums.length]; // right2Left[i] = nums[i]*nums[i+1]*...*nums[nums.length-1] left2Right[0] = nums[0]; right2Left[nums.length-1] = nums[nums.length-1]; for (int i=1; i&amp;lt;nums.length-1; i++) { left2Right[i] = left2Right[i-1] * nums[i]; } for (int i=nums.length-2; i&amp;gt;0; i--) { right2Left[i] = right2Left[i+1] * nums[i]; } int[] result = new int[nums.length]; result[0] = right2Left[1]; result[nums.length-1] = left2Right[nums.length-2]; for (int i=1; i&amp;lt;nums.length-1; i++) { result[i] = left2Right[i-1] * right2Left[i+1]; } return result; }}Check out the description of these two problems at LC 238." }, { "title" : "LeetCode 274.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/21/LeetCode-274.html", "date" : "June 21, 2024", "excerpt" : "QuestionGiven an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher&amp;#39;s h-index.According to the definition of h-index on Wikipedia: The h-index is defined a...", "content" : "QuestionGiven an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher&#39;s h-index.According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.IntuitionThe answer must be located in the range:0 &amp;lt;= answer &amp;lt;= Math.min(citations.length, Max(citations[i]))Then, I try Binary Search (usually the time complexity of BS solution is O(nlogn))ApproachThe initial left and right value should be: left = 0 or 1 (if the minimum length of citations is 1) right = Math.min(citations.length, Max(citations[i]))Complexity Time complexity: O(nlogn) Space complexity: O(1) Codeclass Solution { public static int hIndex(int[] citations) { int max = -1; for (int c: citations) { max = Math.max(max, c); } int left = 0, right = Math.min(citations.length, max); int count; while (left &amp;lt;= right) { int mid = left + (right - left) / 2; count = 0; for (int c: citations) { if (c &amp;gt;= mid) { count++; } } if (count &amp;lt; mid) { right = mid - 1; }else{ left = mid + 1; } } return left - 1; }}Check out the description of these two problems at LC 274." }, { "title" : "LeetCode 1052.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/21/LeetCode-1052.html", "date" : "June 21, 2024", "excerpt" : "QuestionThere is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the s...", "content" : "QuestionThere is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.Return the maximum number of customers that can be satisfied throughout the day.IntuitionThe quesiton is tedious and redundant so I first do some transformation:Calculate the maximum number of customers whom could be satisfied while bookstore owner has a chance to change their attitude on a consecutive number of days.Approach declare an array to represent how many customers will be unsatisfied on each day calculate how many customers will be satisfied due to the bookstore owner’s secret technique on minutes consecutive days The answer will be addition of the maximum from step 2 and customers whom are satisfied originallyComplexity Time complexity: O(n) Space complexity: O(n) Codeimport java.util.Arrays;class Solution { public int maxSatisfied(int[] customers, int[] grumpy, int minutes) { int n = customers.length; int[] notSatisfied = new int[n]; for (int i=0; i&amp;lt;n; i++) {//n notSatisfied[i] = customers[i] * grumpy[i]; } int prev = 0; for (int i=0; i&amp;lt;minutes; i++) {//n prev += notSatisfied[i]; } int max = prev; for (int i=minutes; i&amp;lt;n; i++) {//n prev = prev - notSatisfied[i - minutes] + notSatisfied[i]; max = Math.max(max, prev); } for (int i=0; i&amp;lt;n; i++) {//n if (grumpy[i] == 0) { max += customers[i]; } } return max; }}Check out the description of these two problems at LC 1052." }, { "title" : "LeetCode 1552.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/20/LeetCode-1552.html", "date" : "June 20, 2024", "excerpt" : "QuestionIn the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribu...", "content" : "QuestionIn the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.Rick stated that magnetic force between two different balls at positions x and y is |x - y|.Given the integer array position and the integer m. Return the required force.IntuitionFrom the description, we can know that the answer should be in the range : 0&amp;lt;=answer&amp;lt;=10^9-1 because 1&amp;lt;=x,y&amp;lt;=10^9.On my first thought, I wanna use BS to get the answer because the answer is the specific range (meaning we can use BS)ApproachAccording to my first thought, my solution should be like this: sorting initial array (cuz BS requires sorted array) getting a current value by BS testing if the value is qualified pointer moves left if the value is qualified; otherwise pointer moves rightThe rest we need to figure out is: What is the definition of qualification? or How to judge if the value is qualified?.Here is my answer: Use Greedy Algorithm. First we create a counter which equals m. Then we get the first element of sorted array and set it as previous element. Once the |current - previous| &amp;gt;= range(BS generated) we then set current value as previous element and the counter minus one. Until the counter turns to 0 (qualified) or the iteration is done (not qualified).Complexity Time complexity: O(nlogn) Space complexity: O(1) Codeimport java.util.Arrays;class Solution { public int maxDistance(int[] position, int m) { Arrays.sort(position); //nlogn int left = 0, right = (position[position.length-1]-position[0]) / (m-1); while (left &amp;lt;= right) {//logn int mid = left + (right - left) / 2; if (!isQualified(position, m, mid)) {//n right = mid - 1; }else{ left = mid + 1; } } return left - 1; } public boolean isQualified(int[] position, int m, int range) { m--; // always get the first element int prev = position[0]; for (int i=0; i&amp;lt;position.length; i++) { if (position[i]-prev &amp;gt;= range) { if (--m == 0) { // counter turns to 0 return true; } prev = position[i]; } } return false; }}Check out the description of these two problems at LC 1552." }, { "title" : "LeetCode 121 &amp; 122.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/20/LeetCode-121-&-122.html", "date" : "June 20, 2024", "excerpt" : "IntroLeetCode 121 &amp;amp;amp; LeetCode 122 are similiar so here I put them in a same page.LeetCode 121. Best time to Buy and Sell StockYou are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize yo...", "content" : "IntroLeetCode 121 &amp;amp; LeetCode 122 are similiar so here I put them in a same page.LeetCode 121. Best time to Buy and Sell StockYou are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.IntuitionGot the point that we can only buy &amp;amp; sell stock once. As a result, we can divide the problem into several sub-problems: calculate the max profit we can earn while buying stock on each day (because there must be a transaction if max profit was existed) compare resultsThe time complexity of comparison should be O(n).ApproachNow, we need to figure out: Calculate the max profit we can earn while buying stock on each day.We know if we buy stock on day i (1&amp;lt;=i&amp;lt;=n), we have to sell it on day k (i&amp;lt; k &amp;lt;=n). In addition, stock price on day k should be the highest in the range of days (i to n). Here comes two constraints: buy on day i &amp;amp; sell on day k (1 &amp;lt;= i &amp;lt; k &amp;lt;= n) prices[k] &amp;gt;= prices[x] (i &amp;lt; x &amp;lt;= n)First set a variable to keep the max price during day x to day n (represents prices[k]). Then create an array to record max profit while buying stock on day i, the value should be prices[k]-prices[i]. Finally, do the comparison of each day’s max profit.Complexity Time complexity: O(n) Space complexity: O(n) Codeclass Solution { // LeetCode 121: Best time to Buy and Sell Stock public int maxProfit(int[] prices) { int max = prices[prices.length-1]; int[] maxProfit = new int[prices.length]; for (int i=prices.length-2; i&amp;gt;=0; i--) { maxProfit[i] = Math.max(0, max - prices[i]); max = Math.max(max, prices[i]); } max = 0; for (int mp: maxProfit) { max = Math.max(max, mp); } return max; }}LeetCode 122. Best time to Buy and Sell Stock IIYou are given an integer array prices where prices[i] is the price of a given stock on the ith day.On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.Find and return the maximum profit you can achieve.IntuitionSince we can sell and buy stock on the same day, we can buy stock whatever prices go down or high. If prices go down then we sell it immediately. Otherwise, we sell it on the next day.ApproachUse Greedy AlgorithmComplexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { // LeetCode 122: Best time to Buy and Sell Stock II public int maxProfit(int[] prices) { int profit = 0; for (int i=0; i&amp;lt;prices.length; i++) { if (i+1 &amp;lt; prices.length &amp;amp;&amp;amp; prices[i] &amp;lt; prices[i+1] ) { profit += prices[i+1]-prices[i]; } } return profit; }}Check out the description of these two problems at LC 121, LC 122." }, { "title" : "LeetCode 189.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/20/LeetCode-189.html", "date" : "June 20, 2024", "excerpt" : "Intuitionkeep a subarray of right side of array and replace right side of it by left side. After that, replace the other side.Approach create a subarray which size is equal to k to keep the right side of array replace right side by left side fir...", "content" : "Intuitionkeep a subarray of right side of array and replace right side of it by left side. After that, replace the other side.Approach create a subarray which size is equal to k to keep the right side of array replace right side by left side first then replace left side by right sideComplexity Time complexity: O(n) Space complexity: O(k) Codeclass Solution { public void rotate(int[] nums, int k) { k = k % nums.length; int[] tmp = new int[k]; for (int i=nums.length-k; i&amp;lt;nums.length; i++) { tmp[i + k - nums.length] = nums[i]; } for (int i=nums.length-k-1; i&amp;gt;=0; i--) { nums[i + k] = nums[i]; } for (int i=0; i&amp;lt;k; i++) { nums[i] = tmp[i]; } }}Check out the description of this problem at LC 189." }, { "title" : "LeetCode 80.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/20/LeetCode-80.html", "date" : "June 20, 2024", "excerpt" : "IntuitionAn intuitive thought: iterate the given array and record the steps that number on current index needed to be replaced forward. Then, this implementation’s time complexity will be O(n).Approach set a variable to record the previous duplic...", "content" : "IntuitionAn intuitive thought: iterate the given array and record the steps that number on current index needed to be replaced forward. Then, this implementation’s time complexity will be O(n).Approach set a variable to record the previous duplicated number set another variable to count current duplicated number of values set a variable to record how many steps to move value on current index to targeted index set a pointer to iterate the given arrayComplexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public int removeDuplicates(int[] nums) { int prev = 10001, count = 0; int pt = -1, move = 0; while (++pt &amp;lt; nums.length) { if (nums[pt] == prev) { if (++count &amp;gt; 2) { move++; } }else{ prev = nums[pt]; count = 1; } nums[pt - move] = nums[pt]; } return nums.length - move; }}Check out the description of this problem at LC 80." }, { "title" : "Prime Number", "category" : "", "tags" : " Algorithm", "url" : "/demo/2024/06/19/Prime-Number.html", "date" : "June 19, 2024", "excerpt" : "IntroApproach 1 gives the method to test whether n is a prime number.Approach 2 gives the method to test whether numbers in a given range are prime numbers.Approach 1 A prime number (or a prime) is a natural number greater than 1 that is not a pr...", "content" : "IntroApproach 1 gives the method to test whether n is a prime number.Approach 2 gives the method to test whether numbers in a given range are prime numbers.Approach 1 A prime number (or a prime) is a natural number greater than 1 that is not a product of two smaller natural numbers (except 1). According to the definition, I iterate the pt from 2 to n to see if n is a prime number by testing pt is a factor of n. However, I could narrow the possible range of pt from 2 to n/2, which the smallest possible factor of n is 2. For the same reason, 3 is the second smallest possible factor of n. I could further simplify the range of pt because the biggest possible factor of n is sqrt(n) (a larger factor of n must be a multiple of a smaller factor that has been already checked). Codeclass Solution { // Approach 1: Simple way public boolean isPrime(int n) { if (n &amp;lt;= 1) return false; // Check from 2 to sqrt(n) for (int i = 2; i &amp;lt;= Math.sqrt(n); i++) if (n % i == 0) return false; return true; } }Approach 2 Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit. First, assuming every 2k+1 number is prime number in the given range. Secondly, marking the frontest number which is currently prime (named i) as prime number and every i*c (c is N) number as non-prime Third, simplifying the range of i*c =&amp;gt; i*2c because every even c is non-prime. Then, start calculating from i*i instead of i*1 because i*1 to i*(i-1) is checked before. Codeclass Solution { // Appraoch 2: Sieve of Eratosthenes public boolean[] isPrime(int n) { if (n &amp;lt;= 2) return 0; boolean[] isPrime = new boolean[n]; for (int i=3; i&amp;lt;n; i+=2) { isPrime[i] = true; } isPrime[2] = true; for (int i=3; i&amp;lt;Math.sqrt(n); i+=2) { if (isPrime[i]) { // if i is prime for (int j=i*i; j&amp;lt;n; j+=i*2) { // mark i*i, i*(i+2), i*(i+4),... as non-prime, which i=2k+1 isPrime[j] = false; } } } return isPrime; }}Reference Sieve of Eratosthenes" }, { "title" : "LeetCode 204.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/19/LeetCode-204.html", "date" : "June 19, 2024", "excerpt" : "IntuitionOn first glimpse, I try DP and turn out TLE, shit again.Then, I try Sieve of Eratosthenes which is an algorithm to get prime numbers in a designated range.ApproachUse Sieve of EratosthenesComplexity Time complexity: O(nlogn) S...", "content" : "IntuitionOn first glimpse, I try DP and turn out TLE, shit again.Then, I try Sieve of Eratosthenes which is an algorithm to get prime numbers in a designated range.ApproachUse Sieve of EratosthenesComplexity Time complexity: O(nlogn) Space complexity: O(1) Codeclass Solution { /*DP shit again public boolean isPrime(int n) { if (n &amp;lt;= 1) return false; if (n == 2 || n == 3) return true; if (n % 2 == 0 || n % 3 == 0) return false; for (int i = 5; i &amp;lt;= Math.sqrt(n); i = i + 6) if (n % i == 0 || n % (i + 2) == 0) return false; return true; } public int countPrimes(int n) { if (n-1 &amp;lt;= 1) return 0; int[] result = new int[n]; for (int i=2; i&amp;lt;=n-1; i++) { result[i] = result[i - 1]; if (isPrime(i)) { result[i]++; } } return result[n-1]; } */ // Sieve of Eratosthenes public static int countPrimes(int n) { if (n &amp;lt;= 2) return 0; boolean[] isPrime = new boolean[n]; for (int i=3; i&amp;lt;n; i+=2) { isPrime[i] = true; } isPrime[2] = true; for (int i=3; i&amp;lt;Math.sqrt(n); i+=2) { if (isPrime[i]) { // if i is prime for (int j=i*i; j&amp;lt;n; j+=i*2) { // mark i*i, i*(i+1), i*(i+2),... as non-prime isPrime[j] = false; } } } int result = 0; for (int i=2; i&amp;lt;n; i++) { if (isPrime[i]) result++; } return result; }}Check out the description of this problem at LC 204." }, { "title" : "LeetCode 278.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/19/LeetCode-278.html", "date" : "June 19, 2024", "excerpt" : "IntuitionBinary Seaching to find the answerApproachBinary SeachingComplexity Time complexity: O(logn) Space complexity: O(1) Codeclass Solution { public int firstBadVersion(int n) { int left = 1, right = n, mid = left + (rig...", "content" : "IntuitionBinary Seaching to find the answerApproachBinary SeachingComplexity Time complexity: O(logn) Space complexity: O(1) Codeclass Solution { public int firstBadVersion(int n) { int left = 1, right = n, mid = left + (right - left) / 2; while (left &amp;lt;= right) { if (left == right) return left; mid = left + (right - left) / 2; if (isBadVersion(mid)) { right = mid; }else{ left = mid + 1; } } return mid; }}Check out the description of this problem at LC 278." }, { "title" : "LeetCode 1482.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/19/LeetCode-1482.html", "date" : "June 19, 2024", "excerpt" : "IntuitionI use dynamic programming on my first thought. It works but turns out to be TLE.Then I saw the range of input parameters that each bloomDay[i] should be smaller than 10^9.The implementation should be simplified to a searching problem so I...", "content" : "IntuitionI use dynamic programming on my first thought. It works but turns out to be TLE.Then I saw the range of input parameters that each bloomDay[i] should be smaller than 10^9.The implementation should be simplified to a searching problem so I try Binary Search on my second thought.ApproachAssume the answer is ans, 1 &amp;lt;= ans &amp;lt;= 10^9. Use BS to find the answer.Initialize the parameters we’ll use: left = 1 right = 10^9 mid = 1 + (10^9-1)/2 answer=midIf bloomDay is qualified to current mid, then the answer must be located in the range of left and mid (left &amp;lt;= ans &amp;lt;= mid). Otherwise, it must be located between mid+1 and right (mid+1 &amp;lt;= ans &amp;lt;= right)When bloomDay is qualified, left &amp;lt;= answer &amp;lt;= midOtherwise, mid + 1&amp;lt;=answer&amp;lt;=rightComplexity Time complexity: O(nlogn) Space complexity: O(logn) Codeclass Solution { // First Attempt /* public static int minDays(int[] bloomDay, int m, int k) { if (m * k &amp;gt; bloomDay.length) return -1; // Try Dynamic Programming // arr[n - k + 1], 表示從index處開始取k個的值 int[] minCost = new int[bloomDay.length - k + 1]; for (int i=0; i&amp;lt;bloomDay.length - k + 1; i++) { minCost[i] = bloomDay[i]; for (int j=1; j&amp;lt;k; j++) { minCost[i] = Math.max(minCost[i], bloomDay[i + j]); } } // GOAL: 取m個值總和最小; CONSTRAINT: 兩者相隔必須k return dp(minCost, k, 0, m, 0); } public static int dp(int[] minCost, int k, int start, int left, int cost) { if (cost &amp;lt; 0) return -1; if (left == 0) return cost; if (start &amp;gt;= minCost.length) return -1; int n = minCost.length + k - 1; if ((n - start - 1) / k + 1 &amp;lt; left) return -1; int get = dp(minCost, k, start + k, left-1, Math.max(cost, minCost[start])); int pass = dp(minCost, k, start + 1, left, cost); if (get &amp;lt; 0 &amp;amp;&amp;amp; pass &amp;lt; 0) return -1; else if (get &amp;lt; 0) return pass; else if (pass &amp;lt; 0) return get; return Math.min(get, pass); } */ // Second Attempt: BS public int minDays(int[] bloomDay, int m, int k) { if (m * k &amp;gt; bloomDay.length) return -1; //由於結果只會在1和10^9之間產生則使用BS int l = 1, r = 1000000000; int min = -1; while (l &amp;lt;= r) { int mid = l + (r - l) / 2; int consecutive = 0, count = 0; for (int i=0; i&amp;lt;bloomDay.length; i++) { if (bloomDay[i] &amp;lt;= mid) { if (++consecutive == k) { consecutive = 0; count++; } }else{ consecutive = 0; } } if (count &amp;gt;= m) { min = mid; r = mid - 1; }else{ l = mid + 1; } } return min; }}Check out the description of this problem at LC 1482." }, { "title" : "LeetCode 633.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/17/LeetCode-633.html", "date" : "June 17, 2024", "excerpt" : "Intuitiona^2 + b^2 = c; (a &amp;amp;gt;= 0 &amp;amp;amp; b &amp;amp;gt;= 0 &amp;amp;amp; a,b,c are integers)Simply get the constraints: a,b &amp;amp;lt;= sqrt(c)ApproachIterate a,b from 0 to sqrt(c). Be careful to the limit of integer 2^31 - 1.As a result, use subtra...", "content" : "Intuitiona^2 + b^2 = c; (a &amp;gt;= 0 &amp;amp; b &amp;gt;= 0 &amp;amp; a,b,c are integers)Simply get the constraints: a,b &amp;lt;= sqrt(c)ApproachIterate a,b from 0 to sqrt(c). Be careful to the limit of integer 2^31 - 1.As a result, use subtraction instead of addition.Complexity Time complexity: O(n) Space complexity: O(1) Codeclass Solution { public boolean judgeSquareSum(int c) { int init = (int) Math.sqrt(c); int tmp = 0, tmp1 = 0; for (int i=0; i &amp;lt;= init; i++) { tmp = c - i*i; tmp1 = (int) Math.sqrt(tmp); if (tmp == tmp1 * tmp1) { return true; } } return false; }}Check out the description of this problem at LC 633." }, { "title" : "LeetCode 945.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/14/LeetCode-945.html", "date" : "June 14, 2024", "excerpt" : "IntuitionAfter sorting, every index number should become the nearest bigger number to current valueApproachUse Arrays sorting algorithm and greedy algorithm after sortingComplexity Time complexity: O(nlogn) + O(n) = O(nlogn) Space comp...", "content" : "IntuitionAfter sorting, every index number should become the nearest bigger number to current valueApproachUse Arrays sorting algorithm and greedy algorithm after sortingComplexity Time complexity: O(nlogn) + O(n) = O(nlogn) Space complexity: O(1) Codeclass Solution { public int minIncrementForUnique(int[] nums) { Arrays.sort(nums); //nlogn int i = 0; int cnt = 0; for (var n : nums) { //n i = Math.max(i, n); cnt += i - n; i++; } return cnt; }}Check out the description of this problem at LC 945." }, { "title" : "Heap Sort", "category" : "", "tags" : " Algorithm", "url" : "/demo/2024/06/13/Heap-Sort.html", "date" : "June 13, 2024", "excerpt" : "class Solution { /*Solution 1*/ public void sort(int arr[]) { int n = arr.length; // Build heap (rearrange array) for (int i = n / 2 - 1; i &amp;amp;gt;= 0; i--) heapify(arr, n, i); // One by one extra...", "content" : "class Solution { /*Solution 1*/ public void sort(int arr[]) { int n = arr.length; // Build heap (rearrange array) for (int i = n / 2 - 1; i &amp;gt;= 0; i--) heapify(arr, n, i); // One by one extract an element from heap for (int i = n - 1; i &amp;gt;= 0; i--) { // Move current root to end int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; // call max heapify on the reduced heap heapify(arr, i, 0); } } // To heapify a subtree rooted with node i which is // an index in arr[]. n is size of heap void heapify(int arr[], int n, int i) { int largest = i; // Initialize largest as root int l = 2 * i + 1; // left = 2*i + 1 int r = 2 * i + 2; // right = 2*i + 2 // If left child is larger than root if (l &amp;lt; n &amp;amp;&amp;amp; arr[l] &amp;gt; arr[largest]) largest = l; // If right child is larger than largest so far if (r &amp;lt; n &amp;amp;&amp;amp; arr[r] &amp;gt; arr[largest]) largest = r; // If largest is not root if (largest != i) { int swap = arr[i]; arr[i] = arr[largest]; arr[largest] = swap; // Recursively heapify the affected sub-tree heapify(arr, n, largest); } } /*Solution 2*/ public void heapSort(int[] nums) { int tmp = 0; for (int i=0; i&amp;lt;nums.length; i++) { nums = heapify(nums, i); } for (int i=nums.length-1; i&amp;gt;=0; i--) { tmp = nums[0]; nums[0] = nums[i]; nums[i] = tmp; nums = topHeapify(nums, i + 1); } } public int[] heapify(int[] nums, int index) { int prev = index, current = (index + 1) / 2 - 1; int tmp = 0; while (current &amp;gt;= 0 &amp;amp;&amp;amp; nums[current] &amp;lt; nums[prev]) { tmp = nums[current]; nums[current] = nums[prev]; nums[prev] = tmp; prev = current; current = (current + 1) / 2 - 1; } return nums; } public int[] topHeapify(int[] nums, int limit) { int prev = 0, left = 1, right = 2; int tmp = 0, sw = left; while ((left &amp;lt; limit &amp;amp;&amp;amp; nums[prev] &amp;lt; nums[left]) || (right &amp;lt; limit &amp;amp;&amp;amp; nums[prev] &amp;lt; nums[right])) { if (left &amp;lt; limit &amp;amp;&amp;amp; right &amp;lt; limit) { sw = nums[left] &amp;gt; nums[right] ? left : right; }else if (left &amp;lt; limit &amp;amp;&amp;amp; nums[prev] &amp;lt; nums[left]) { sw = left; }else{ sw = right; } tmp = nums[sw]; nums[sw] = nums[prev]; nums[prev] = tmp; prev = sw; left = (sw + 1) * 2 - 1; right = (sw + 1) * 2; } return nums; }}" }, { "title" : "LeetCode 215.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/13/LeetCode-215.html", "date" : "June 13, 2024", "excerpt" : "class Solution { public int findKthLargest(int[] nums, int k) { int[] result = mergeSort(0, nums.length-1, nums); return result[nums.length-k]; } public int[] mergeSort(int start, int end, int[] arr) { int half = ...", "content" : "class Solution { public int findKthLargest(int[] nums, int k) { int[] result = mergeSort(0, nums.length-1, nums); return result[nums.length-k]; } public int[] mergeSort(int start, int end, int[] arr) { int half = (int)((end - start) * 0.5); if (end - start &amp;lt; 2) { return cmp(start, end, arr); } return conquer(mergeSort(start, start + half, arr), mergeSort(start + half + 1, end, arr)); } public int[] cmp(int start, int end, int[] arr) { if (end - start == 0) return new int[]{arr[start]}; if (arr[end] &amp;lt; arr[start]) return new int[]{arr[end], arr[start]}; return new int[]{arr[start], arr[end]}; } public int[] conquer(int[] a, int[] b){ int pta = 0, ptb = 0; int[] result = new int[a.length + b.length]; while (pta &amp;lt; a.length &amp;amp;&amp;amp; ptb &amp;lt; b.length) { if (a[pta] &amp;lt;= b[ptb]) { result[pta + ptb] = a[pta]; pta++; }else{ result[pta + ptb] = b[ptb]; ptb++; } } if (pta == a.length) { for (int i=ptb; ptb&amp;lt;b.length; ptb++) { result[a.length+ptb]=b[ptb]; } }else{ for (int i=pta; pta&amp;lt;a.length; pta++) { result[b.length+pta]=a[pta]; } } return result; } }" }, { "title" : "Merge Sort", "category" : "", "tags" : " Algorithm", "url" : "/demo/2024/06/13/Merge-Sort.html", "date" : "June 13, 2024", "excerpt" : "import java.time.Duration;import java.time.Instant;class Solution { /** * 1. 當前數組長度大於二則切分兩半 * 2. 直到當前數組長度&amp;amp;lt;=2 * 3. 若長度為1則直接返回；否則比較兩者大小後返回 * 4. 對返回的兩個數組做比大小；注意此步驟只需對比頭元素即可(因為已排序) * 5. 比較並合併為原本的數組大小 */ public int[...", "content" : "import java.time.Duration;import java.time.Instant;class Solution { /** * 1. 當前數組長度大於二則切分兩半 * 2. 直到當前數組長度&amp;lt;=2 * 3. 若長度為1則直接返回；否則比較兩者大小後返回 * 4. 對返回的兩個數組做比大小；注意此步驟只需對比頭元素即可(因為已排序) * 5. 比較並合併為原本的數組大小 */ public int[] mergeSort(int start, int end, int[] arr) { int half = (int)((end - start) * 0.5); if (end - start &amp;lt; 2) { return cmp(start, end, arr); } return conquer(mergeSort(start, start + half, arr), mergeSort(start + half + 1, end, arr)); } public int[] cmp(int start, int end, int[] arr) { if (end - start == 0) return new int[]{arr[start]}; if (arr[end] &amp;lt; arr[start]) return new int[]{arr[end], arr[start]}; return new int[]{arr[start], arr[end]}; } public int[] conquer(int[] a, int[] b){ int pta = 0, ptb = 0; int[] result = new int[a.length + b.length]; while (pta &amp;lt; a.length &amp;amp;&amp;amp; ptb &amp;lt; b.length) { if (a[pta] &amp;lt;= b[ptb]) { result[pta + ptb] = a[pta]; pta++; }else{ result[pta + ptb] = b[ptb]; ptb++; } } if (pta == a.length) { for (int i=ptb; ptb&amp;lt;b.length; ptb++) { result[a.length+ptb]=b[ptb]; } }else{ for (int i=pta; pta&amp;lt;a.length; pta++) { result[b.length+pta]=a[pta]; } } return result; } public static void main(String[] args) { int arr[] = new int[80000]; for(int i = 0; i &amp;lt; 80000; i++) { arr[i] = (int)(Math.random() * 80000); } int temp[] = new int[arr.length]; Instant startTime = Instant.now(); mergeSort(arr, 0, arr.length - 1, temp); Instant endTime = Instant.now(); System.out.println(&quot;Time Cost：&quot; + Duration.between(startTime, endTime).toMillis() + &quot; ms&quot;); }}" }, { "title" : "LeetCode 2037.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/13/LeetCode-2037.html", "date" : "June 13, 2024", "excerpt" : "class Solution { public int minMovesToSeat(int[] seats, int[] students) { int result = 0; int[] sseats = mergeSort(0, seats.length-1, seats); int[] sstudents = mergeSort(0, seats.length-1, students); for (int i=0; i&amp;...", "content" : "class Solution { public int minMovesToSeat(int[] seats, int[] students) { int result = 0; int[] sseats = mergeSort(0, seats.length-1, seats); int[] sstudents = mergeSort(0, seats.length-1, students); for (int i=0; i&amp;lt;seats.length; i++) { result += Math.abs(sstudents[i] - sseats[i]); } return result; } public int[] mergeSort(int start, int end, int[] arr) { int half = (int)((end - start) * 0.5); if (end - start &amp;lt; 2) { return cmp(start, end, arr); } return conquer(mergeSort(start, start + half, arr), mergeSort(start + half + 1, end, arr)); } public int[] cmp(int start, int end, int[] arr) { if (end - start == 0) return new int[]{arr[start]}; if (arr[end] &amp;lt; arr[start]) return new int[]{arr[end], arr[start]}; return new int[]{arr[start], arr[end]}; } public int[] conquer(int[] a, int[] b){ int pta = 0, ptb = 0; int[] result = new int[a.length + b.length]; while (pta &amp;lt; a.length &amp;amp;&amp;amp; ptb &amp;lt; b.length) { if (a[pta] &amp;lt;= b[ptb]) { result[pta + ptb] = a[pta]; pta++; }else{ result[pta + ptb] = b[ptb]; ptb++; } } if (pta == a.length) { for (int i=ptb; ptb&amp;lt;b.length; ptb++) { result[a.length+ptb]=b[ptb]; } }else{ for (int i=pta; pta&amp;lt;a.length; pta++) { result[b.length+pta]=a[pta]; } } return result; }}Check out the description of this problem at LC 2037." }, { "title" : "LeetCode 75.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/06/12/LeetCode-75.html", "date" : "June 12, 2024", "excerpt" : "class Solution { public void sortColors(int[] nums) { //[2,0,2,1,1,0] =&amp;amp;gt; [0,0,1,1,2,2] int[] cnt = new int[3]; for (int i=0; i&amp;amp;lt;nums.length; i++) { cnt[nums[i]]++; } int indA = 0, indB ...", "content" : "class Solution { public void sortColors(int[] nums) { //[2,0,2,1,1,0] =&amp;gt; [0,0,1,1,2,2] int[] cnt = new int[3]; for (int i=0; i&amp;lt;nums.length; i++) { cnt[nums[i]]++; } int indA = 0, indB = 0; while (indA &amp;lt; 3) { while (cnt[indA]-- &amp;gt; 0) { nums[indB++] = indA; } indA++; } }}Check out the description of this problem at LC 75." }, { "title" : "Netty Self-taught Diary (2)", "category" : "", "tags" : " Tech-Share", "url" : "/demo/2024/02/05/Netty-Self-Taught-Diary-2.html", "date" : "February 5, 2024", "excerpt" : "ByteBuffer(Java)/ByteBuf(Netty) 先來介紹數據類型ByteBuf，這個ByteBuf類是Netty根據Java的ByteBuffer所演化而來的，兩者都是爲了處理數據而產生。因爲在ChannelHandler中所接收到的數據只能保證順序而沒辦法保證接收到的段落。例如Client中按順序發送: “Hello”, “World”；但是到了Server端的ChannelHandler可能會被分成”He”,”lloW”,”orld”，因此需要設計一種數據類型...", "content" : "ByteBuffer(Java)/ByteBuf(Netty) 先來介紹數據類型ByteBuf，這個ByteBuf類是Netty根據Java的ByteBuffer所演化而來的，兩者都是爲了處理數據而產生。因爲在ChannelHandler中所接收到的數據只能保證順序而沒辦法保證接收到的段落。例如Client中按順序發送: “Hello”, “World”；但是到了Server端的ChannelHandler可能會被分成”He”,”lloW”,”orld”，因此需要設計一種數據類型來處理這類情況。前面所述的情況是因爲傳輸協議本身沒辦法保證，而并非是受到Netty框架所影響。 在介紹這個數據類之前還要先知道在Java NIO中是如何設計的，這樣方便做直觀的比較而且兩者也有相似之處。java.nio.bytebuffer 是 java.nio.buffer 的子類，而ByteBuffer中分爲兩種Buffer: Direct Buffer 和 None-Direct Buffer。就如同名字所述，direct buffer被分配在heap之外，能直接被程序訪問，所以速度較none-direct快；而none-direct buffer被存放在heap中，也就是大部分程序訪問數據的流程，而通常Java會為這個buffer再額外分配一個array用來備份數據，這個array被稱爲 Backing Array。因此，可以在程序中透過 hasArray() 來檢查這個buffer是否擁有backing array，若是有就代表這個buffer屬於none-direct(heap buffer)，反之為direct buffer: Direct Buffer None-Direct buffer 位於heap外，可以直接被stack中的java程序調用 位於heap内 訪問速度快 訪問速度慢 要釋放較麻煩 釋放容易 沒有backing array 有backing array 使用 allowcateDirect() 創建 先 allocate() 創建buffer，然後在手動創建backing array並把它與buffer綁定（調用 wrap()） 讓我們把視角回到Netty的ByteBuf類型，它包含了三種格式，除了前面提到的HeapBuffer和DirectBuffer，Netty還設計了CompositeBuffer，它表示多個ByteBuf的組合類，方便同時處理和傳遞多個ByteBuf；同時若要讀取CompositeByteBuf，可以把它視爲DirectBytebuf，因爲在CompositeByteBuf中并沒有Backing Array。下面就是使用CompositeByteBuf組合兩個ByteBuf和讀取其中數據的範例，非常直觀的描述前面提到的觀念: // 創建CompositeByteBufCompositeByteBuf messageBuf = Unpooled.compositeBuffer();ByteBuf buf_1 = ...; // can be backing or directByteBuf buf_2 = ...; // can be backing or directmessageBuf.addComponents(buf_1, buf_2);// 讀取CompositeByteBuf后針對array處理即可int length = compBuf.readableBytes();byte[] array = new byte[length];compBuf.getBytes(compBuf.readerIndex(), array); 介紹完不同種類的Buffer后，讓我們把是視角拉回Buffer内部。若是要訪問Buffer的數據，Netty又與原生Java做出區別，這邊爲了簡化流程故而用表格做對比，相信也會更加直觀的看出差異，由於ByteBuffer設計不同，故而使用方法也差距甚大，這邊先不琢磨細節，等到後續使用時再詳細説明： Java NIO Netty ByteBuffer擁有四個基礎屬性: capacity/limit/position/mark。capacity 表示這個buffer定義大小，一但聲明了便不可更改；limit 表示不應該被讀取/寫入資料的位置，例如 [0,limit) 可以被讀取，而 [limit, capacity] 則棄用；position 表示目前讀取/寫入的指針；mark被用來保存當前的position屬性用於後續的重置 擁有兩個主要屬性: writerIndex 和 readerIndex 用於分別表示在讀寫中的指針 由於只有一個position記錄當下位置，因此需要使用flip()/clear()切換讀寫模式，還需要注意limit和position之間的關係，非常複雜 兩個指針分別記錄讀寫模式下的位置，避免許多繁雜的操作以及不必要的問題 How to read/write ByteBuf +-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes |+-------------------+------------------+------------------+| | | |0 &amp;lt;= readerIndex &amp;lt;= writerIndex &amp;lt;= capacity 前面提到在ByteBuf中有兩個基礎屬性readerIndex和writerIndex，分別指向當前讀指針和寫指針。先來介紹讀取部分，Netty提供兩種主要讀取的方法: read 和 get；前者當你讀取時指針會跟著變動，後者則不會，這樣做的目的是當你只是用於判斷式且不想讓指針移動時便可以使用get來防止下次讀取時指針跑掉。另外，Netty提供很多類型的read和get方法，下面就以ByteBuf.getByte做介紹： getByte(int i)getBytes(int i, ByteBuf dst)getBytes(int i, ByteBuf dst, int len)getBytes(int i, ByteBuf dst, int dstIndex, int len) 我們假設調用方法的為 ByteBuf target getByte(int i): 最直接將數據從target讀出, readerIndex不變 getBytes(int i, ByteBuf dst): 將數據從target讀出並存入到dst中，target的readerIndex不變但dst的writerIndex會變 getBytes(int i, ByteBuf dst, int len): 將長度為len的數據從target讀出並存入到dst中，target的readerIndex不變但dst的writerIndex會變 getBytes(int i, ByteBuf dst, int dstIndex, int len): 將長度為len的數據從target讀出並從dst的dstIndex位置開始存放，target的readerIndex不變且dst的writerIndex也不變 相反的，若是使用 read 方法，則readerIndex 會改變並影響到下次讀取的位置，這邊便不再贅述，可以參考 Netty 4.x API。同理，寫入部分Netty提供的是 set 和 write 兩種類型，前者寫入時 writerIndex 不變，後者則會隨著寫入長度改變 參考資料 Netty in Action Java NIO - Buffer Basic Concepts Netty 4.x API" }, { "title" : "Netty Self-taught Diary (1)", "category" : "", "tags" : " Tech-Share", "url" : "/demo/2024/02/03/Netty-Self-Taught-Diary-1.html", "date" : "February 3, 2024", "excerpt" : "Intro 本來很久之前就想自己寫一個聊天程式自己用，但是一直苦於Netty官網上艱澀的User Guide 自己本身學的是java，但之前對Java IO只有些許瞭解，再加上完全沒有使用過原生IO，所以一直不得其門 最近有空想説再來學習一下Netty并且自己建立一個項目學習，如有不對之處望指正！ What is Netty? Netty is an NIO client server framework which enables qui...", "content" : "Intro 本來很久之前就想自己寫一個聊天程式自己用，但是一直苦於Netty官網上艱澀的User Guide 自己本身學的是java，但之前對Java IO只有些許瞭解，再加上完全沒有使用過原生IO，所以一直不得其門 最近有空想説再來學習一下Netty并且自己建立一個項目學習，如有不對之處望指正！ What is Netty? Netty is an NIO client server framework which enables quick and easy development of network applicationssuch as protocol servers and clients. It greatly simplifies and streamlines network programming suchas TCP and UDP socket server. 簡單來説Netty可以用在處理高并發的IO項目中，不管是Sevrer/Client都可以適用 Netty components 首先Netty設計了幾個特殊的、包裝過的類；借由這些類來實現高并發和提升性能: Channel: 對應Java API裏的Socket ChannelFuture: 在Netty中很多異步的Channel並不會馬上返回，因此需要這樣一個ChannelFuture類來表示返回類型 ChannelHandler: 是開發者使用Netty時最專注的模塊，因爲幾乎所有BL都是在這邊實現，有點類似于Interceptor，只不過細部概念後續説明，這邊只要知道它是處理ChannelPipeline中流通的events並將處理結果傳給後續的Handler ChannelPipeline: 每一個Channel在生成的時候都會指派一個屬於自己的ChannelPipeline用於處理在這個Channel中所有的Handler和Events；注意光看命名其實容易搞混，可以理解爲Channel擁有的Pipeline,換句話説是存在于Channel裏的 ChannelHandlerContext: 可以理解表示ChannelHandler與ChannelPipeline之間的關係，也可以從中獲取ChannelPipeline依附的Channel，但通常來説這個類用來處理outbound數據 Inbound/Outbound: 簡單來説就是數據流通方向，若是往外流就是Outbound；往内流就是Inbound。例如在Client端中若要設計一個ChannelHandler用於處理從Server發送的數據，那麽就應該繼承ChannelInboundHandler/Adapter類似的類 EventLoopGroup: 在Netty中一個EventLoopGroup擁有多個EventLoop，而一個EventLoop永遠對應一個Thread，并且一個Channel在它的整個生命周期中只綁定一個EventLoop；但相反的一個EventLoop可以擁有多個Channel。這點與傳統Java IO不同，一個Channel通常只對應一個Thread，若要使用不堵塞則使用threadPool，但在Java IO中一個thread也只能對應一個channel 0. Build Server 通過上面的介紹，應該對其中幾個類都有一定的瞭解。若要建立一個最簡單的Server則需要兩個部分： ChannelHandler: 處理流通在ChannelPipeline上的所有事件(event)，例如最簡單的當Client發送訊息時，Server接受到之後想要返回一段特殊字串，那就需要在ChannelHandler裏實現 Bootstrap: Server端的啓動流程，包括綁定端口、初始化EventLoopGroup，以及各種定義如若是Connection生成后Channel的類/ChannelPipeline上有哪些ChannelHandler以及他們的順序等等 不多說，直接看代碼來學習是最快的方法，下面實現的是一個返回Client端發送訊息的Server: EchoServerHandler.java import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class EchoServerHandler extends ChannelInboundHandlerAdapter{ @Override public void channelRead(ChannelHandlerContext ctx, Object msg){ ByteBuf in = (ByteBuf) msg; System.out.println( &quot;Server received:&quot; + in.toString(CharsetUtil.UTF_8) ); ctx.write(in); } @Override public void channelReadComplete(ChannelHandlerContext ctx){ ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause){ cause.printStackTrace(); ctx.close(); }} EchoServer.java import java.net.InetSocketAddress;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class EchoServer { private static int port = 8080; public static void main(String[] args) throws Exception{ EchoServer.start(); } public static void start() throws Exception { EventLoopGroup group = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override public void initChannel(SocketChannel ch){ ch.pipeline().addLast(new EchoServerHandler()); } }); ChannelFuture cf = b.bind().sync(); cf.channel().closeFuture().sync(); } finally { group.shutdownGracefully().sync(); } }} 首先代碼非常簡單，如同前面所説分爲兩個部分：ChannelHandler 實現了一個 ChannelInboundHandlerAdapter 類用於幫助生成其他基本的方法，這裏覆寫了三個方法分別是: channelRead() 用於處理接收到的數據 channelReadComplete() 用於表示在 channelRead()方法結束后要做什麽 exceptionCaught() 表示若有異常在這個ChannelHandler中發生要怎麽處理，是要直接關閉這個channel還是如何 再來看到 Bootstrap 部分: ServerBootstrap: 這是Netty提供的初始啓動輔助類，幫助使用者簡化流程，并將許多類挂載到這上面 EventLoopGroup group; &amp;amp; b.group(group): 如同前面所提到的將一個EventLoop分配給Channel .channel(NioServerSocketChannel.class): 指定Channel的類型 .localAddress(new InetSocketAddress(port)): 綁定這個Server要在哪個端口監聽請求 .childHandler(…): 將前面定義的Channel上的所有ChannelHandler並將他們加到自己的ChannelPipeline上。注意這個 addLast() 中可以添加多個 ChannelHandler，并且他們之間的順序也是添加的順序。 ChannelFuture cf = b.bind().sync(): 啓動監聽并且將這個步驟設置為同步堵塞(sync)，也就是這行代碼沒有執行完之前不會執行後面的代碼。因爲這個方法並不是馬上傳回值，因此這個方法返回的是 ChannelFuture 最後若是前面堵塞的代碼結束，表示Channel要關閉，因此執行channel.closeFuture() 學習資料 Netty in Action.pdf Netty Ofiicial" }, { "title" : "Separated Frontend &amp; Backend System Development(2)", "category" : "", "tags" : " Tech-Share", "url" : "/demo/2024/01/26/Separated-Frontend-&-Backend-System-Development(2).html", "date" : "January 26, 2024", "excerpt" : "前後端分離系統開發介紹(2) 2. 前端 2.1 前置工作 Vue需要使用到Node.js和npm；前者是一個Web Application framework；後者是Node.js預設的Dependency Manager；兩者都需要安裝，詳情見官網 創建Vue項目不需要任何IDE，只需要在安裝完npm后執行命令npm install -g vue-cli先安裝Vue的輔助程序，這個輔助程序可以生成空項目 然後執行...", "content" : "前後端分離系統開發介紹(2) 2. 前端 2.1 前置工作 Vue需要使用到Node.js和npm；前者是一個Web Application framework；後者是Node.js預設的Dependency Manager；兩者都需要安裝，詳情見官網 創建Vue項目不需要任何IDE，只需要在安裝完npm后執行命令npm install -g vue-cli先安裝Vue的輔助程序，這個輔助程序可以生成空項目 然後執行vue create xxx就可生成項目，其中xxx是項目名 如果需要可見 Vue官網 查詢各種API和框架介紹 2.2 整體框架 -node_modules-public-src -assets -views -components -store -index.js -router -index.js -App.vue -main.js-package.json-package-lock.json-vue.config.js... node_modules是所有依賴存放目錄 package.json是npm用來管理這個vue項目依賴的配置文件；借由package.json來生成更加全面的依賴樹package-lock.json。若要更改或添加依賴可通過手動加入package.json或執行npm install xxx vue.config.js是一個可選的配置文件，會被vue-cli加載 src/views和src/components并不是强制要求的目錄，只是規範: views/存放整個頁面的組件；components/存放小的或可組合的組件 src/store負責全局數據的定義 src/router負責組件路由的定義 public存放靜態資源 2.3 模塊/文件介紹 2.3.1 .vue 文件基本介紹 &amp;lt;template&amp;gt; &amp;lt;div class=&quot;outer&quot;&amp;gt; &amp;lt;SW nav=&quot;login&quot;&amp;gt;&amp;lt;/SW&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import SW from &#39;./SwitchLoginRegister.vue&#39;export default { name: &#39;LoginPage&#39;, components: { SW }, props: { msg: String }, mounted() data(){ return{ username: &#39;&#39;, ... } }, methods:{ function() { ... }, }}&amp;lt;/script&amp;gt;&amp;lt;style scoped&amp;gt;...&amp;lt;/style&amp;gt; 在Vue項目中，一個.vue文件就默認是一個組件，而所有的組件都是挂載在 App.vue 這個根組件上；組件與組件之間並沒有聯係，可以通過在一個組件中導入另一個組件來實現父子組件。 一個.vue文件基本由三個部分組成: &amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;、&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt; 和 &amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;。&amp;lt;template&amp;gt; 是聲明最基礎的html標簽和整體佈局，&amp;lt;template&amp;gt;標簽内至少需要一個標簽作爲根標簽，因爲前面提到的組件導入就是從這個根標簽作爲嵌入點。例如上面的A組件導入B組件最終就會變爲A(下面): &amp;lt;template&amp;gt; &amp;lt;div class=&quot;A&quot;&amp;gt; &amp;lt;B&amp;gt;&amp;lt;/B&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div class=&quot;B&quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;template&amp;gt; &amp;lt;div class=&quot;A&quot;&amp;gt; &amp;lt;div class=&quot;B&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt;是為整個組件提供脚本的地方，最外層包含了一個組件的聲明，同時裏面還有很多實用的屬性: components聲明從外部導入組件；props允許父組件傳遞數據給子組件；mounted()在每個組件加載時會調用的方法(類似JAVA中的構造函數，詳情見Vue Lifecycle)；data聲明這個組件内使用到的數據；methods聲明組件内使用到的方法 &amp;lt;style&amp;gt;與基礎的寫法相同 2.3.2 main.js import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;import store from &#39;./store&#39;import VueRouter from &#39;vue-router&#39;Vue.config.productionTip = falseVue.use(VueRouter)new Vue({ el: &quot;#app&quot;, router: router, store: store, render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;) 負責導入Vue.js庫和其他使用到的全局庫和組件 創建Vue實例，並將其掛載到HTML文檔中的一個DOM元素上，通常是一個div元素。可由下列例子(App.vue)中看出，main.js把整個Vue實例掛載到App.vue中的&amp;lt;div id=&quot;app&quot;&amp;gt;上，把這個&amp;lt;div&amp;gt;當作最外層的HTML元素: ``` - 配置Vue實例的選項，例如路由器（Vue Router）、狀態管理器（Vuex）以及其他插件。- 最後，啟動Vue應用程序。#### 2.3.3 Vuex(狀態管理)`Vuex` 是Vue項目中最重要的觀念之一，它管理項目中所有的狀態。由於Vue本身設計原因，數據流通僅能通過父組件單方面通知子組件，而不能實現雙向流通。因此Vuex能掌控並響應所有數據變化就變得尤爲重要，所有 `Vuex` 的觀念和使用可在 [官網](https://v3.vuex.vuejs.org/) 查詢。首先要瞭解Vue中的`data`和`computed`有何區別；`data`沒辦法做到當其他組件改變值，這個組件也跟著改變；而`computed`則是如果這個方法裏的值變動並會改變計算結果就會更新，這個特性可以結合 `Vuex-store` 來使得當一個全局值變動則所有組件一起變動- store/index.js import Vue from ‘vue’import Vuex from ‘vuex’ Vue.use(Vuex) const store = new Vuex.Store({ state: { username: ‘’, password: ‘’, mail: ‘’ }, mutations: { set_username(state, newVal) { state.username = newVal }, set_password(state, newVal){ state.password = newVal }, set_mail(state, newVal) { state.mail = newVal } }})export default store - `Vue.use(Vuex)` 是讓 `Vuex` 挂載在 `Vue` 實例上，在 `main.js`上導入即可使得全局都可以使用這個配置- `state` 是Vuex的基本狀態，通過定義在 `state` 裏可以在各個組件内部通過 `this.$store.state` 調用，非常方便- `mutations` 是爲了解決很多組件若要調用相同的方法都需要再寫一遍，若是現在 `store/index.js` 中定義就能在各個組件中直接調用方法- 另外 `Vuex` 還有其他觀念如 Getters/Actions 本次案例中沒有使用到，可查閲 [文檔](https://v3.vuex.vuejs.org/) 學習#### 2.3.4 Router路由功能是Vue提供的基本跳轉功能,使用方法也很簡單- router/index.js import Router from ‘vue-router’import LoginPage from ‘../components/LoginPage.vue’ const router = new Router({ routes: [ { path: ‘/’, name: ‘mainPage’, redirect: ‘/login’ }, { path: ‘/login’, name: ‘login’, component: LoginPage } ]})export default router -創建一個Router實例並將其挂載到全局Vue實例上(main.js)## 3. 演示 client: http://localhost:3000/server: http://localhost:8080/demo/ - startup cd %NGINX_HOME%start nginx cd %TOMCAT_HOME%\\bin./startup - shutdown cd %NGINX_HOME%nginx.exe -s quit cd %TOMCAT_HOME%\\bin./shutdown```" }, { "title" : "Separated Frontend &amp; Backend System Development(1)", "category" : "", "tags" : " Tech-Share", "url" : "/demo/2024/01/26/Separated-Frontend-&-Backend-System-Development(1).html", "date" : "January 26, 2024", "excerpt" : "前後端分離系統開發介紹(1) 0. 前言 前端為一個項目，後端為一個項目，分別部署后前端調用後端提供的API，總體來説可以看作兩個獨立的項目。通過這樣可以使得雙方專注與自己的部分，并且修改其中一端并不會影響到另一端的運行情況 本次介紹案例都在本地執行，前端使用 Vue+Nginx；後端使用 Springboot+Tomcat springboot: 3.2.2 vue: 2.6.14 vuex: 3.6.2 ngin...", "content" : "前後端分離系統開發介紹(1) 0. 前言 前端為一個項目，後端為一個項目，分別部署后前端調用後端提供的API，總體來説可以看作兩個獨立的項目。通過這樣可以使得雙方專注與自己的部分，并且修改其中一端并不會影響到另一端的運行情況 本次介紹案例都在本地執行，前端使用 Vue+Nginx；後端使用 Springboot+Tomcat springboot: 3.2.2 vue: 2.6.14 vuex: 3.6.2 nginx: 1.25.1 tomcat: 10.1.18 Springboot是SpringMVC的便捷版，可讓開發人員專注在開發細節上而非繁雜的配置；另外Springboot嵌入在Tomcat、Jetty、Undertow上所以不需要額外部署它 體量比較: SpringMVC &amp;lt; Spring &amp;lt; Springboot Spring使用很多特殊的注解(annotation)作爲輔助，需要查閲官方文檔學習 Vue本次使用 Vue v2 + Vuex v3; Vuex是Vue的狀態管理模式庫，通俗來説就是管理流通在Vue中的各種數據。另外Vue項目對各類庫的版本兼容很狹隘，Vue2/Vue3對應的依賴版本相差很多，可以使用 npm audit fix 檢查全部依賴的關聯性；原生的Vue2 官方文檔 1. 後端 1.1 範例項目架構 -src -main -java -controller -bl(business logic) -blImpl(business logic Implementation) -vo -po(dto) -dao -utils -resources -application.yml -application-prod.yml -application-dev.yml -test 1.2 配置文件 項目裏的配置文件默認為src/main/resources/application.yaml或替代為application.properties，兩者語法不同需注意，下面是一個簡單的例子 spring: application: name: SpringbootDemo datasource: url: jdbc:mysql://localhost:3306/demo_table username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver platform: mysql schema: classpath:schema.sql data: classpath:data.sql initialization: alwaysmybatis: mapper-locations: classpath:mapper/*Mapper.xmlserver: port: 8090 還可以開發環境配置跟產品上線配置不同，在application.yaml中如下: spring:profiles: active: prod #switch prod/dev 然後生成application-prod.yaml和application-dev.yaml就可以切換 1.3 依賴文件 使用Maven管理項目依賴，下面是一個簡單的例子 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\t\t xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;\t&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;\t&amp;lt;parent&amp;gt;\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;\t\t&amp;lt;version&amp;gt;2.5.5&amp;lt;/version&amp;gt;\t\t&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;\t&amp;lt;/parent&amp;gt;\t&amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;\t&amp;lt;artifactId&amp;gt;caseLibrary&amp;lt;/artifactId&amp;gt;\t&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;\t&amp;lt;name&amp;gt;caseLibrary&amp;lt;/name&amp;gt;\t&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;\t&amp;lt;properties&amp;gt;\t\t&amp;lt;java.version&amp;gt;8&amp;lt;/java.version&amp;gt;\t&amp;lt;/properties&amp;gt;\t&amp;lt;dependencies&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.springdoc&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;springdoc-openapi-ui&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;version&amp;gt;1.1.45&amp;lt;/version&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;\t\t\t&amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;version&amp;gt;8.0.19&amp;lt;/version&amp;gt;\t\t\t&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;jdom&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;jdom&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t\t&amp;lt;dependency&amp;gt;\t\t\t&amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;\t\t\t&amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;version&amp;gt;1.18.20&amp;lt;/version&amp;gt;\t\t&amp;lt;/dependency&amp;gt;\t&amp;lt;/dependencies&amp;gt;\t&amp;lt;build&amp;gt;\t\t&amp;lt;plugins&amp;gt;\t\t\t&amp;lt;plugin&amp;gt;\t\t\t\t&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\t\t\t\t&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;\t\t\t&amp;lt;/plugin&amp;gt;\t\t&amp;lt;/plugins&amp;gt;\t&amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt; 1.4 SpringBoot架構 Springboot開發還是遵循SpringMVC，只不過把其中的View部分轉換成獨立的一個項目而并非包含在Spring項目中，因此後端項目只負責到Controller層。詳細關係為Contorller中注入Service，Service中注入DAO，因此可以把它視爲三層結構。大致關係如下: Frontend -&amp;gt; Controller -&amp;gt; Service -&amp;gt; Repository -&amp;gt; Model(ORM) 1.4.0 Application Main Entrance 繼承 SpringBootServletInitializer 是要讓這個Springboot程序能以WAR包的形式部署到外部Servlet容器中 @SpringBootApplicationpublic class CaseLibraryApplication extends SpringBootServletInitializer{ public static void main(String[] args) { SpringApplication.run(CaseLibraryApplication.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){ return builder.sources(BackendDemoApplication.class); }} 1.4.1 Controller層 @RestController@RequestMapping(&quot;/graph&quot;)public class GraphController { @Autowired private LawService lawService; @Autowired private LinkService linkService; @PostMapping(&quot;/getGraphData&quot;) public ResponseVO getGraphData(@RequestBody SearchTargetVO searchTargetVO){ return linkService.getLinks(searchTargetVO.getSearchTarget()); } @PostMapping(&quot;/addLink&quot;) public ResponseVO addLink(@RequestBody LinkVO linkVO){ return linkService.addLink(linkVO); } @PostMapping(&quot;/deleteLinks&quot;) public ResponseVO deleteLinks(@RequestBody SearchTargetVO searchTargetVO) { return linkService.deleteLink(searchTargetVO.getSearchTarget()); }} @RestController表示這個類是Controller層，并且創造的是REST API @RequestMapping表示HTTP Request的路徑 @Autowired將Service層的類注入到這層也就是Controller層 @PostMapping(&quot;/addLink&quot;)聲明HTTP Request的類別和路徑 @RequestBody可以使Controller接收到HTTP Client傳送的JSON數據，並將數據映射為預先設計好的Java類，例如在上述例子中的addLink()中的LinkVO類便是設計好的Java類，在設計層面上來説這個LinkVO屬於VO(Value Object)，屬於Controller響應前端請求后返回的數據格式，下面是LinkVO的例子: public class LinkVO { private String source; private String target; private String rela; public String getSource() { return source; } public void setSource(String source) { this.source = source; } public String getTarget() { return target; } public void setTarget(String target) { this.target = target; } public String getRela() { return rela; } public void setRela(String rela) { this.rela = rela; }} 有個好用的庫可以簡化手動生成Get/Set方法lombok: 使用時在maven中添加依賴 &amp;lt;dependency&amp;gt;\t&amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;\t&amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;\t&amp;lt;version&amp;gt;1.18.20&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; 簡化項目中的DAO/PO/VO.etc，LinkVO便可簡化為: @Datapublic class LinkVO { private String source; private String target; private String rela;} 值得一提的是，ResponseVO是默認返回給前端的類，使得前端處理後端返回的數據時不會因爲不同API而有不同的預處理方法，下面是ResponseVO的設計可供參考: public class ResponseVO { // 表示這次請求是否成功 private Boolean success; // 顯示的訊息不管成功或者失敗 private String message; // 返回的數據 private Object content; public static ResponseVO buildSuccess(){ ResponseVO response=new ResponseVO(); response.setSuccess(true); return response; } public static ResponseVO buildSuccess(Object content){ ResponseVO response=new ResponseVO(); response.setContent(content); response.setSuccess(true); return response; } public static ResponseVO buildFailure(String message){ ResponseVO response=new ResponseVO(); response.setSuccess(false); response.setMessage(message); logger.error(message); return response; }} 1.4.2 Service層 也就是Business Logic層，是主要處理數據邏輯的模塊。所有的處理都在這層實現，並不會延申到Controller層(也就是說Controller層只是負責處理Http Request)。設計思路有很多，但是大體可以分爲兩部分: Service Interface和Service Implementation。Interface主要聲明要完成的方法，白話說就是TODO List；Implementation是實現Interface的模塊，下面提供一個例子: LinkService(Interface) public interface LinkService { ResponseVO getLinks(String lawTitle); ResponseVO enterFormData(); ResponseVO getRuleBySourceTitle(String searchTarget); ResponseVO addLink(LinkVO linkVO); ResponseVO deleteLink(String source);} LinkServiceImpl(Implementaiton) @Servicepublic class LinkServiceImpl implements LinkService { @Autowired private LinkRepository linkRepository; @Override public ResponseVO getLinks(String lawTitle) { return ResponseVO.buildSuccess(linkRepository.findBySource(lawTitle)); } ...} @Service表示這個類屬於Service層 LinkRepository類為DAO層，所以在Service層中注入並使用 1.4.3 Model (PO) 在介紹Model和Repository之前，要先介紹Spring Data JPA與其餘ORM的關係。本次介紹使用Spring Data JPA并非傳統JPA Provider(如hibernate)，論層級來説它應該處於JPA之上JPA Provider之下，它默認使用hibernate來實現細節(可以在pom依賴下看到spring-data-jpa有子依賴hibernate-core)。它是獨立于Spring framework上的技術，并且不需要開發者實現細節，只需要根據規則套用注解即可。 @Entity@Table(name = &quot;link&quot;)@Datapublic class Link { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @NotNull @Column(name = &quot;source&quot;,columnDefinition = &quot;varchar(255)&quot;,nullable = false) private String source; @Column(name = &quot;target&quot;,columnDefinition = &quot;varchar(255)&quot;,nullable = false) private String target; @NotNull @Column(name = &quot;relationship&quot;,columnDefinition = &quot;varchar(255)&quot;,nullable = false) private String relation;} @Entity 是Spring Data JPA中的注解，通常來説添加這個注解就默認生成一個表(這個注解下的類)為表名 @Table(name = &quot;link&quot;)如果要指定特定表名則可以使用此注解 @Id @GeneratedValue 是每個表必要的Id列，@GeneratedValue則制定Id列生成規則 @Column聲明列 1.4.4 Repository (DAO) Spring Data JPA需要我們設計Repository的Interface，在運行過程中它會自動生成這個Repository的實現，避免我們手動生成冗長的代碼如Connection等。因此我們只需專注在SQL語句即可。另外，它兼容原生的SQL語句 public interface LinkRepository extends JpaRepository&amp;lt;Link, Integer&amp;gt; { List&amp;lt;Link&amp;gt; findBySource(String source); @Transactional @Query(value = &quot;select * from link where source like concat(&#39;%&#39;,:source,&#39;%&#39;)&quot;, nativeQuery = true) List&amp;lt;Link&amp;gt; searchBySource(String source); @Transactional @Query(value = &quot;select count(*) from link where &quot; + &quot;source like concat(&#39;%&#39;,:source,&#39;%&#39;) and &quot; + &quot;target like concat(&#39;%&#39;,:target,&#39;%&#39;) and &quot; + &quot;relationship like concat(&#39;%&#39;,:relation,&#39;%&#39;)&quot;, nativeQuery = true) Integer findLinkBySTR(@Param(&quot;source&quot;) String source, @Param(&quot;target&quot;) String target, @Param(&quot;relation&quot;) String relation); @Transactional void deleteLinksBySource(String source);} LinkRepository繼承JpaRepository，它提供很多默認方法如基礎的CRUD: 即使在LinkRepository中沒有聲明find方法，在繼承JpaRepository后仍可依照規則調用。簡單來説，Spring Data JPA是可以讓使用者使用Interface和特定的Function Design來完成ORM的使用。例如在上述例子中，JpaRepository&amp;lt;Link, Integer&amp;gt;使用Link表(1-3-3), ID為Integer類型。Link類中有id, source, target, relation四列；則LinkRepository默認就擁有下列方法: findById(Integer id)...findAll()deleteById(Integer id)...deleteAll()save(Link link)... 可以節省很多時間并且非常直觀，同時也接受Override改變其方法實現 @Transactional表示將此方法視爲一個事務，當此方法失敗則不會影響到其他的事務，若是此方法中其中一個操作失敗則全部一起失敗並rollback數據(可以定義rollback rules) @Query表示詳細的SQL語句，有很多屬性和規則，可在官方文檔查詢 @Param可以指定在SQL中使用:name來代替?1" }, { "title" : "LeetCode 746.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/14/LeetCode-746.html", "date" : "January 14, 2024", "excerpt" : "package lc_746;public class Solution { public int minCostClimbingStairs(int[] cost) { int len = cost.length; int[] current_min_cost = new int[len]; current_min_cost[0] = cost[0]; current_min_cost[1] = cost[1]; ...", "content" : "package lc_746;public class Solution { public int minCostClimbingStairs(int[] cost) { int len = cost.length; int[] current_min_cost = new int[len]; current_min_cost[0] = cost[0]; current_min_cost[1] = cost[1]; for (int i=2; i&amp;lt;len; i++){ current_min_cost[i] = Math.min(current_min_cost[i-1], current_min_cost[i-2]) + cost[i]; } return Math.min(current_min_cost[len-1], current_min_cost[len-2]); }}Check out the description of this problem at LC 746." }, { "title" : "LeetCode 938.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-938.html", "date" : "January 11, 2024", "excerpt" : "package lc_938;public class Solution { int total; public int rangeSumBST(TreeNode root, int low, int high) { if (root == null) return 0; if (root.val &amp;amp;gt;= low &amp;amp;amp;&amp;amp;amp; root.val &amp;amp;lt;= high){ total +...", "content" : "package lc_938;public class Solution { int total; public int rangeSumBST(TreeNode root, int low, int high) { if (root == null) return 0; if (root.val &amp;gt;= low &amp;amp;&amp;amp; root.val &amp;lt;= high){ total += root.val; } rangeSumBST(root.left, low, high); rangeSumBST(root.right, low, high); return total; }}Check out the description of this problem at LC 938." }, { "title" : "LeetCode 790.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-790.html", "date" : "January 11, 2024", "excerpt" : "package lc_790;public class Solution { public final int modulo = 1000000007; public int numTilings(int n) { if (n == 1) return 1; int[] A = new int[n + 1]; int[] BC = new int[n + 1]; A[1] = 1; A[2] = 2; ...", "content" : "package lc_790;public class Solution { public final int modulo = 1000000007; public int numTilings(int n) { if (n == 1) return 1; int[] A = new int[n + 1]; int[] BC = new int[n + 1]; A[1] = 1; A[2] = 2; BC[1] = 0; BC[2] = 1; for (int i=3; i&amp;lt;=n; i++){ A[i] = (A[i-1] + A[i-2] + 2 * BC[i-1]) % modulo; BC[i] = (A[i-2] + BC[i-1]) % modulo; } System.out.println(Integer.MAX_VALUE); return A[n]; }}Check out the description of this problem at LC 790." }, { "title" : "LeetCode 714.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-714.html", "date" : "January 11, 2024", "excerpt" : "package lc_714;public class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; int[] hold = new int[len]; int[] not_hold = new int[len]; hold[0] = -prices[0]-fee; int hold_max = ...", "content" : "package lc_714;public class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; int[] hold = new int[len]; int[] not_hold = new int[len]; hold[0] = -prices[0]-fee; int hold_max = Integer.MIN_VALUE; int not_hold_max = Integer.MIN_VALUE; int ans = Integer.MIN_VALUE; int last_hold_max = Integer.MIN_VALUE; int last_not_hold_max = Integer.MIN_VALUE; for (int i=1; i&amp;lt;len; i++){ last_hold_max = Math.max(last_hold_max, hold[i-1]); last_not_hold_max = Math.max(last_not_hold_max, not_hold[i-1]); hold_max = Math.max(hold_max, last_not_hold_max); not_hold_max = Math.max(not_hold_max, last_hold_max); hold[i] = hold_max - prices[i] - fee; not_hold[i] = not_hold_max + prices[i]; ans = Math.max(ans, not_hold[i]); } return Math.max(ans, 0); }// public int maxProfit(int[] prices, int fee) {// int len = prices.length;// int[] hold = new int[len];// int[] not_hold = new int[len];//// hold[0] = -prices[0]-fee;// int hold_max = Integer.MIN_VALUE;// int not_hold_max = Integer.MIN_VALUE;// int ans = Integer.MIN_VALUE;//// for (int i=1; i&amp;lt;len; i++){// for (int j=i; j&amp;gt;0; j--){// hold_max = Math.max(hold_max, not_hold[j-1]);// not_hold_max = Math.max(not_hold_max, hold[j-1]);// }// hold[i] = hold_max - prices[i] - fee;// not_hold[i] = not_hold_max + prices[i];// ans = Math.max(ans, not_hold[i]);// }// return Math.max(ans, 0);// }}Check out the description of this problem at LC 714." }, { "title" : "LeetCode 452.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-452.html", "date" : "January 11, 2024", "excerpt" : "package lc_452;import java.util.Arrays;public class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, (a,b) -&amp;amp;gt; Integer.compare(a[0], b[0])); int ans = 1; int previous = 0; for (int ...", "content" : "package lc_452;import java.util.Arrays;public class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, (a,b) -&amp;gt; Integer.compare(a[0], b[0])); int ans = 1; int previous = 0; for (int i=0; i&amp;lt;points.length; i++){ if (points[i][0] &amp;gt; points[previous][1]){ ans ++; previous = i; } } return ans; }}Check out the description of this problem at LC 452." }, { "title" : "LeetCode 435.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-435.html", "date" : "January 11, 2024", "excerpt" : "package lc_435;import java.util.Arrays;import java.util.Stack;public class Solution { public int eraseOverlapIntervals(int[][] intervals) { if(intervals == null || intervals.length == 0) return 0; Arrays.sort(intervals, (a,b)-&amp;amp...", "content" : "package lc_435;import java.util.Arrays;import java.util.Stack;public class Solution { public int eraseOverlapIntervals(int[][] intervals) { if(intervals == null || intervals.length == 0) return 0; Arrays.sort(intervals, (a,b)-&amp;gt;Integer.compare(a[0],b[0])); int ans = 0; int previous = 0; int n = intervals.length; for(int current = 1; current &amp;lt; n; current++) { if(intervals[current][0] &amp;lt; intervals[previous][1]) { ans++; if(intervals[current][1] &amp;lt;= intervals[previous][1]) { previous = current; } } else { previous = current; } } return ans; }}Check out the description of this problem at LC 435." }, { "title" : "LeetCode 368.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-368.html", "date" : "January 11, 2024", "excerpt" : "package lc_368;import java.util.*;public class Solution { List&amp;amp;lt;Integer&amp;amp;gt; max; int[] dp; public List&amp;amp;lt;Integer&amp;amp;gt; largestDivisibleSubset(int[] nums) { max = new ArrayList&amp;amp;lt;&amp;amp;gt;(); dp=new int[n...", "content" : "package lc_368;import java.util.*;public class Solution { List&amp;lt;Integer&amp;gt; max; int[] dp; public List&amp;lt;Integer&amp;gt; largestDivisibleSubset(int[] nums) { max = new ArrayList&amp;lt;&amp;gt;(); dp=new int[nums.length]; Arrays.sort(nums); Arrays.fill(dp,-1); recur(nums, 0, new ArrayList&amp;lt;&amp;gt;()); return max; } public void recur(int[] nums, int index, List&amp;lt;Integer&amp;gt; current){ if (index &amp;gt;= nums.length){ if (current.size() &amp;gt; max.size()){ max.clear(); max.addAll(current); } return; } // Take account of this function while current.size is bigger than maximum size // which is calculated before; dp[index] means the maximum size of answer list // from nums[0] to nums[index] if (current.isEmpty() || (current.size() &amp;gt; dp[index] &amp;amp;&amp;amp; nums[index] % current.get(current.size()-1) == 0)){ dp[index] = current.size(); current.add(nums[index]); recur(nums, index+1, current); current.remove(current.size() - 1); } recur(nums, index+1, current); }}Check out the description of this problem at LC 368." }, { "title" : "LeetCode 357.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-357.html", "date" : "January 11, 2024", "excerpt" : "package lc_357;public class Solution { int[] dp = new int[9]; public Solution() { dp[0] = 1; dp[1] = 10; dp[2] = 91; for(int i=3; i&amp;amp;lt;9; i++) { int count = 9; int ans = 9; for...", "content" : "package lc_357;public class Solution { int[] dp = new int[9]; public Solution() { dp[0] = 1; dp[1] = 10; dp[2] = 91; for(int i=3; i&amp;lt;9; i++) { int count = 9; int ans = 9; for(int j=1; j&amp;lt;i; j++) { ans = ans * count; count--; } dp[i] = dp[i - 1] + ans; } } public int countNumbersWithUniqueDigits(int n) { return dp[n]; }}Check out the description of this problem at LC 357." }, { "title" : "LeetCode 343.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-343.html", "date" : "January 11, 2024", "excerpt" : "package lc_343;public class Solution { public int integerBreak(int n) { if (n &amp;amp;lt;= 5){ int[] t = new int[]{1,2,4,6}; return t[n-2]; } int[] ans = new int[]{4,6,9}; int count = n - 5, tmp; ...", "content" : "package lc_343;public class Solution { public int integerBreak(int n) { if (n &amp;lt;= 5){ int[] t = new int[]{1,2,4,6}; return t[n-2]; } int[] ans = new int[]{4,6,9}; int count = n - 5, tmp; while (--count &amp;gt; 0){ tmp = ans[0] * 3; ans[0] = ans[1]; ans[1] = ans[2]; ans[2] = tmp; } return ans[2]; }}Check out the description of this problem at LC 343." }, { "title" : "LeetCode 338.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-338.html", "date" : "January 11, 2024", "excerpt" : "package lc_338;public class Solution { public int[] countBits(int n) { int count = 0, tmp = 0; int[] ans = new int[n + 1]; for (int i=1; i&amp;amp;lt;=n; i++){ if (i % 2 == 0){ ans[i] = ans[i / 2]; ...", "content" : "package lc_338;public class Solution { public int[] countBits(int n) { int count = 0, tmp = 0; int[] ans = new int[n + 1]; for (int i=1; i&amp;lt;=n; i++){ if (i % 2 == 0){ ans[i] = ans[i / 2]; continue; } tmp = i; while (tmp &amp;gt;= 1){ if (tmp &amp;lt;= 2){ count++; break; } count += (tmp % 2); tmp = tmp / 2; } ans[i] = count; count = 0; } return ans; }}Check out the description of this problem at LC 338." }, { "title" : "LeetCode 337.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-337.html", "date" : "January 11, 2024", "excerpt" : "package lc_337;public class Solution { public int rob(TreeNode root) { // Time Exceeded // return recur(root, 0, false); int[] ans = recursion(root); return Math.max(ans[0], ans[1]); } public int recur(TreeNode...", "content" : "package lc_337;public class Solution { public int rob(TreeNode root) { // Time Exceeded // return recur(root, 0, false); int[] ans = recursion(root); return Math.max(ans[0], ans[1]); } public int recur(TreeNode root, int value, boolean banned){ if (root == null) return 0; if (banned) return value + recur(root.left, value, false) + recur(root.right, value, false); int take = root.val, not_take = 0; if (root.left != null){ take += recur(root.left, value, true); not_take += recur(root.left, value, false); } if (root.right != null){ take += recur(root.right, value, true); not_take += recur(root.right, value, false); } return Math.max(take, not_take); } public int[] recursion(TreeNode root){ if (root == null) return new int[2]; int[] r = recursion(root.right); int[] l = recursion(root.left); int[] v = new int[2]; v[0] = root.val + r[1] + l[1]; // take account of current root v[1] = Math.max(r[0], r[1]) + Math.max(l[0], l[1]); // not take account of current root return v; }}Check out the description of this problem at LC 337." }, { "title" : "LeetCode 322.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-322.html", "date" : "January 11, 2024", "excerpt" : "package lc_322;import java.util.Arrays;public class Solution { public int coinChange(int[] coins, int amount) { if (amount == 0) return 0; int[] needed_numbers = new int[amount + 1]; Arrays.fill(needed_numbers, -1); ...", "content" : "package lc_322;import java.util.Arrays;public class Solution { public int coinChange(int[] coins, int amount) { if (amount == 0) return 0; int[] needed_numbers = new int[amount + 1]; Arrays.fill(needed_numbers, -1); needed_numbers[0] = 0; int min = -2; // default needed_numbers[i] = -2 + 1 = -1 for (int i=1; i&amp;lt;=amount; i++){ for (int coin: coins){ if (i - coin &amp;gt;= 0 &amp;amp;&amp;amp; needed_numbers[i-coin] != -1){ if (min == -2) min = needed_numbers[i-coin]; else min = Math.min(needed_numbers[i-coin], min); } } needed_numbers[i] = min + 1; min = -2; } return needed_numbers[amount]; }}Check out the description of this problem at LC 322." }, { "title" : "LeetCode 313.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-313.html", "date" : "January 11, 2024", "excerpt" : "package lc_313;import java.util.*;/** * evolution from LC-264 Ugly Number II */public class Solution { public int nthSuperUglyNumber(int n, int[] primes) { int[] ugly = new int[n]; ugly[0] = 1; int[] index = new int[primes....", "content" : "package lc_313;import java.util.*;/** * evolution from LC-264 Ugly Number II */public class Solution { public int nthSuperUglyNumber(int n, int[] primes) { int[] ugly = new int[n]; ugly[0] = 1; int[] index = new int[primes.length]; int[] factors = Arrays.copyOf(primes, primes.length); int min = Integer.MAX_VALUE, tmp = 0; List&amp;lt;Integer&amp;gt; min_p = new ArrayList&amp;lt;&amp;gt;(); for (int i=1; i&amp;lt;n; i++){ for (int j=0; j&amp;lt;primes.length; j++){ if (factors[j] == min){ min_p.add(j); } if (factors[j] &amp;gt; 0 &amp;amp;&amp;amp; factors[j] &amp;lt; min){ min_p.clear(); min = factors[j]; min_p.add(j); } } ugly[i] = min; while (!min_p.isEmpty()){ tmp = min_p.remove(0); factors[tmp] = primes[tmp] * ugly[++index[tmp]]; } min = Integer.MAX_VALUE; } return ugly[n - 1]; }}Check out the description of this problem at LC 313." }, { "title" : "LeetCode 309.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-309.html", "date" : "January 11, 2024", "excerpt" : "package lc_309;public class Solution { public int maxProfit(int[] prices) { if (prices.length == 1) return 0; if (prices.length == 2){ return prices[1] &amp;amp;gt; prices[0] ? prices[1] - prices[0]: 0; } int ...", "content" : "package lc_309;public class Solution { public int maxProfit(int[] prices) { if (prices.length == 1) return 0; if (prices.length == 2){ return prices[1] &amp;gt; prices[0] ? prices[1] - prices[0]: 0; } int len = prices.length; int[] hold = new int[len]; int[] not_hold = new int[len]; hold[0] = -prices[0]; hold[1] = -Math.min(prices[0], prices[1]); not_hold[1] = Math.max(0, prices[1] - prices[0]); int max_hold = Math.max(hold[0], hold[1]); for (int i=2; i&amp;lt;len; i++){ hold[i] = not_hold[i-2] - prices[i]; max_hold = Math.max(hold[i], max_hold); not_hold[i] = Math.max(not_hold[i-1], max_hold + prices[i]); } return not_hold[len-1]; }}Check out the description of this problem at LC 309." }, { "title" : "LeetCode 300.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-300.html", "date" : "January 11, 2024", "excerpt" : "package lc_300;import java.util.Arrays;public class Solution { public int lengthOfLIS(int[] nums) { int[] dp = new int[nums.length]; int len = 0; for(int x : nums) { int i = Arrays.binarySearch(dp, 0, len, x); ...", "content" : "package lc_300;import java.util.Arrays;public class Solution { public int lengthOfLIS(int[] nums) { int[] dp = new int[nums.length]; int len = 0; for(int x : nums) { int i = Arrays.binarySearch(dp, 0, len, x); if(i &amp;lt; 0) i = -(i + 1); dp[i] = x; if(i == len) len++; } return len; }}Check out the description of this problem at LC 300." }, { "title" : "LeetCode 2870.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-2870.html", "date" : "January 11, 2024", "excerpt" : "package lc_2870;import java.util.HashMap;import java.util.Map;public class Solution { public int minOperations(int[] nums) { HashMap&amp;amp;lt;Integer, Integer&amp;amp;gt; map = new HashMap&amp;amp;lt;&amp;amp;gt;(); for (int num: nums){ ...", "content" : "package lc_2870;import java.util.HashMap;import java.util.Map;public class Solution { public int minOperations(int[] nums) { HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int num: nums){ if (map.containsKey(num)) map.put(num, map.get(num) + 1); else map.put(num, 1); } int count = 0, n = 0; for (Map.Entry&amp;lt;Integer, Integer&amp;gt; m: map.entrySet()){ n = m.getValue(); if (n == 1) return -1; if (n % 3 == 0){ count += n / 3; }else{ count += (n / 3) + 1; } } return count; }}Check out the description of this problem at LC 2870." }, { "title" : "LeetCode 264.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-264.html", "date" : "January 11, 2024", "excerpt" : "package lc_264;public class Solution { int current = 0; public int nthUglyNumber(int n) { int[] ugly = new int[n]; ugly[0] = 1; int index2 = 0, index3 = 0, index5 = 0; int factor2 = 2, factor3 = 3, factor5 = 5; ...", "content" : "package lc_264;public class Solution { int current = 0; public int nthUglyNumber(int n) { int[] ugly = new int[n]; ugly[0] = 1; int index2 = 0, index3 = 0, index5 = 0; int factor2 = 2, factor3 = 3, factor5 = 5; for(int i=1;i&amp;lt;n;i++){ int min = Math.min(Math.min(factor2,factor3),factor5); ugly[i] = min; if(factor2 == min) factor2 = 2*ugly[++index2]; if(factor3 == min) factor3 = 3*ugly[++index3]; if(factor5 == min) factor5 = 5*ugly[++index5]; } return ugly[n-1]; }}Check out the description of this problem at LC 264." }, { "title" : "LeetCode 241.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-241.html", "date" : "January 11, 2024", "excerpt" : "package lc_241;import java.util.ArrayList;import java.util.List;public class Solution { public List&amp;amp;lt;Integer&amp;amp;gt; diffWaysToCompute(String expression) { // simplify expression into one specific pattern: A operator B List&amp;...", "content" : "package lc_241;import java.util.ArrayList;import java.util.List;public class Solution { public List&amp;lt;Integer&amp;gt; diffWaysToCompute(String expression) { // simplify expression into one specific pattern: A operator B List&amp;lt;Integer&amp;gt; total = new ArrayList&amp;lt;&amp;gt;(); for (int i=0; i&amp;lt;expression.length(); i++){ char ch = expression.charAt(i); if (ch == &#39;+&#39; || ch == &#39;-&#39; || ch == &#39;*&#39;){ List&amp;lt;Integer&amp;gt; left = diffWaysToCompute(expression.substring(0, i)); List&amp;lt;Integer&amp;gt; right = diffWaysToCompute(expression.substring(i+1)); for (int l: left){ for (int r: right){ if (ch == &#39;+&#39;) total.add(l+r); else if (ch == &#39;-&#39;) total.add(l-r); else total.add(l*r); } } } } if (total.isEmpty()) total.add(Integer.parseInt(expression)); return total; }}Check out the description of this problem at LC 241." }, { "title" : "LeetCode 221.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-221.html", "date" : "January 11, 2024", "excerpt" : "package lc_221;public class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length; int n = matrix[0].length; int[][] area = new int[m][n]; area[0][0] = matrix[0][0] == &amp;#39;1&amp;#39; ? 1 : 0; ...", "content" : "package lc_221;public class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length; int n = matrix[0].length; int[][] area = new int[m][n]; area[0][0] = matrix[0][0] == &#39;1&#39; ? 1 : 0; int max = area[0][0]; for (int i=1; i&amp;lt;m; i++){ area[i][0] = matrix[i][0] == &#39;1&#39; ? 1 : 0; max = Math.max(max, area[i][0]); } for (int j=1; j&amp;lt;n; j++){ area[0][j] = matrix[0][j] == &#39;1&#39; ? 1 : 0; max = Math.max(max, area[0][j]); } for (int i=1; i&amp;lt;m; i++){ for (int j=1; j&amp;lt;n; j++){ if (matrix[i][j] == &#39;1&#39;){ if (area[i-1][j-1] == 0) area[i][j] = 1; else if (area[i-1][j-1] &amp;lt; Math.min(area[i-1][j], area[i][j-1])) area[i][j] = area[i-1][j]; else area[i][j] = Math.min(area[i-1][j], area[i][j-1]) + 1; max = Math.max(max, area[i][j] * area[i][j]); } } } return max; }}Check out the description of this problem at LC 221." }, { "title" : "LeetCode 213.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-213.html", "date" : "January 11, 2024", "excerpt" : "package lc_213;import java.util.Arrays;public class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int ans = 0; int[] max = new int[nums.length]; max[0] = nums[0]; // take nums[0] ...", "content" : "package lc_213;import java.util.Arrays;public class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int ans = 0; int[] max = new int[nums.length]; max[0] = nums[0]; // take nums[0] max[1] = nums[0]; // not take nums[1] for (int i=2; i&amp;lt;nums.length; i++){ if (i == nums.length - 1){ max[i] = Math.max(max[i-2], max[i-1]); break; } max[i] = Math.max(max[i-2]+nums[i], max[i-1]); } ans = max[nums.length - 1]; Arrays.fill(max, 0); max[0] = 0; max[1] = nums[1]; for (int i=2; i&amp;lt;nums.length; i++){ max[i] = Math.max(max[i-2]+nums[i], max[i-1]); } ans = Math.max(ans, max[nums.length - 1]); return ans; }}Check out the description of this problem at LC 213." }, { "title" : "LeetCode 2125.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-2125.html", "date" : "January 11, 2024", "excerpt" : "package lc_2125;public class Solution { public int numberOfBeams(String[] bank) { int n = bank[0].length(); int m = bank.length; int prev = 0, current = 0, beams = 0; for (int i=0; i&amp;amp;lt;n; i++){ if (ba...", "content" : "package lc_2125;public class Solution { public int numberOfBeams(String[] bank) { int n = bank[0].length(); int m = bank.length; int prev = 0, current = 0, beams = 0; for (int i=0; i&amp;lt;n; i++){ if (bank[0].charAt(i) == &#39;1&#39;) prev++; } for (int j=1; j&amp;lt;m; j++){ for (int i=0; i&amp;lt;n; i++){ if (bank[j].charAt(i) == &#39;1&#39;) current++; } if (current != 0){ beams += prev * current; prev = current; current = 0; } } return beams; }}Check out the description of this problem at LC 2125." }, { "title" : "LeetCode 208.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-208.html", "date" : "January 11, 2024", "excerpt" : "package lc_208;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Trie { Node root; public Trie() { root = new Node(); } public void insert(String word) { root.inse...", "content" : "package lc_208;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Trie { Node root; public Trie() { root = new Node(); } public void insert(String word) { root.insert(word, 0); } public boolean search(String word) { return root.search(word, 0); } public boolean startsWith(String prefix) { return root.startsWith(prefix, 0); } class Node { Node[] nodes; boolean isEnd; Node() { nodes = new Node[26]; } private void insert(String word, int idx) { if (idx &amp;gt;= word.length()) return; int i = word.charAt(idx) - &#39;a&#39;; if (nodes[i] == null) { nodes[i] = new Node(); } if (idx == word.length()-1) nodes[i].isEnd = true; nodes[i].insert(word, idx+1); } private boolean search(String word, int idx) { if (idx &amp;gt;= word.length()) return false; Node node = nodes[word.charAt(idx) - &#39;a&#39;]; if (node == null) return false; if (idx == word.length() - 1 &amp;amp;&amp;amp; node.isEnd) return true; return node.search(word, idx+1); } private boolean startsWith(String prefix, int idx) { if (idx &amp;gt;= prefix.length()) return false; Node node = nodes[prefix.charAt(idx) - &#39;a&#39;]; if (node == null) return false; if (idx == prefix.length() - 1) return true; return node.startsWith(prefix, idx+1); } }}/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */Check out the description of this problem at LC 208." }, { "title" : "LeetCode 198.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-198.html", "date" : "January 11, 2024", "excerpt" : "package lc_198;public class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int len = nums.length; int[] max = new int[len]; max[0] = nums[0]; max[1] = Math.max(nums[1], nums[0]);...", "content" : "package lc_198;public class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int len = nums.length; int[] max = new int[len]; max[0] = nums[0]; max[1] = Math.max(nums[1], nums[0]); for (int i=2; i&amp;lt;len; i++){ max[i] = Math.max(max[i-2]+nums[i], max[i-1]); } return max[len-1]; }}Check out the description of this problem at LC 198." }, { "title" : "LeetCode 1897.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1897.html", "date" : "January 11, 2024", "excerpt" : "package lc_1897;public class Solution { public boolean makeEqual(String[] words) { int len = words.length; int mod = 0; int[] letters = new int[26]; for (String w: words){ mod += w.length() % len; }...", "content" : "package lc_1897;public class Solution { public boolean makeEqual(String[] words) { int len = words.length; int mod = 0; int[] letters = new int[26]; for (String w: words){ mod += w.length() % len; } if (mod % len != 0) return false; int letter = 97; for (String word: words){ for (int i=0; i&amp;lt;word.length(); i++){ letter = word.charAt(i); letters[letter - 97] = (letters[letter - 97] + 1) % len; } } for (int i=0; i&amp;lt;25; i++){ if (letters[i] != 0) return false; } return true; }}Check out the description of this problem at LC 1897." }, { "title" : "LeetCode 1624.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1624.html", "date" : "January 11, 2024", "excerpt" : "package lc_1624;import java.util.Arrays;public class Solution { public int maxLengthBetweenEqualCharacters(String s) { int[] a1 = new int[26]; int[] a2 = new int[26]; int tmp = 0; int ans = -1; Arrays.fill(a1,...", "content" : "package lc_1624;import java.util.Arrays;public class Solution { public int maxLengthBetweenEqualCharacters(String s) { int[] a1 = new int[26]; int[] a2 = new int[26]; int tmp = 0; int ans = -1; Arrays.fill(a1, -1); Arrays.fill(a2, -1); for (int i=0; i&amp;lt;s.length(); i++){ tmp = s.charAt(i) - &#39;a&#39;; if (a1[tmp] == -1){ a1[tmp] = i; }else{ a2[tmp] = i; ans = Math.max(ans, a2[tmp] - a1[tmp] - 1); } } return ans; }}Check out the description of this problem at LC 1624." }, { "title" : "LeetCode 1578.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1578.html", "date" : "January 11, 2024", "excerpt" : "package lc_1578;/** * String ex = &amp;quot;bbbaaa&amp;quot;; * int[] time = new int[]{4,9,3,8,8,9}; * Solution sol = new Solution(); * System.out.println(sol.minCost(ex, time)); */public class Solution { public int minCost(Stri...", "content" : "package lc_1578;/** * String ex = &quot;bbbaaa&quot;; * int[] time = new int[]{4,9,3,8,8,9}; * Solution sol = new Solution(); * System.out.println(sol.minCost(ex, time)); */public class Solution { public int minCost(String colors, int[] neededTime) { int last = 0, index = 0; int time = 0; last = colors.charAt(0); for (int i=1; i&amp;lt;colors.length(); i++){ index = i; while (index &amp;lt; colors.length() &amp;amp;&amp;amp; (int)colors.charAt(index) == last){ index++; } if (index != i){ time += returnSegTotal(i-1, index-1, neededTime); i = index - 1; } last = colors.charAt(i); } return time; } public int returnSegTotal(int from, int to, int[] neededTime){ int max = 0, total = 0; for (int i=from; i&amp;lt;=to; i++){ total += neededTime[i]; if (max &amp;lt; neededTime[i]) max = neededTime[i]; } return total - max; }}Check out the description of this problem at LC 1578." }, { "title" : "LeetCode 152.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-152.html", "date" : "January 11, 2024", "excerpt" : "package lc_152;public class Solution { public int maxProduct(int[] nums) { int left = 1, right = 1; int ans = Integer.MIN_VALUE; for (int i=0; i&amp;amp;lt;nums.length; i++){ left = left == 0 ? 1 : left; r...", "content" : "package lc_152;public class Solution { public int maxProduct(int[] nums) { int left = 1, right = 1; int ans = Integer.MIN_VALUE; for (int i=0; i&amp;lt;nums.length; i++){ left = left == 0 ? 1 : left; right = right == 0 ? 1 : right; left = left * nums[i]; right = right * nums[nums.length-i-1]; ans = Math.max(ans, Math.max(left, right)); } return ans; }}Check out the description of this problem at LC 152." }, { "title" : "LeetCode 139.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-139.html", "date" : "January 11, 2024", "excerpt" : "package lc_139;import java.util.HashSet;import java.util.List;import java.util.Set;/** * List&amp;amp;lt;String&amp;amp;gt; dict = new ArrayList&amp;amp;lt;&amp;amp;gt;(); * dict.add(&amp;quot;apple&amp;quot;); * dict.add(&amp;quot;pen&amp;quot;); * ...", "content" : "package lc_139;import java.util.HashSet;import java.util.List;import java.util.Set;/** * List&amp;lt;String&amp;gt; dict = new ArrayList&amp;lt;&amp;gt;(); * dict.add(&quot;apple&quot;); * dict.add(&quot;pen&quot;); * Solution sol = new Solution(); * System.out.println(sol.wordBreak(&quot;applepenapple&quot;, dict)); */public class Solution {// boolean fit = false;// public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict) {// recur(s, 0, wordDict);// return fit;// }//// public void recur(String s, int start, List&amp;lt;String&amp;gt; wordDict){// if (start == s.length()){// fit = true;// return;// }// for (int i=start; i&amp;lt;s.length(); i++){// if (wordDict.contains(s.substring(start, i+1))){// recur(s, i+1, wordDict);// }// }// } public boolean wordBreak(String s, List&amp;lt;String&amp;gt; wordDict){ boolean [] dp=new boolean[s.length()+1]; dp[0]=true; Set&amp;lt;String&amp;gt; set=new HashSet&amp;lt;&amp;gt;(wordDict); for(int i=1;i&amp;lt;=s.length();i++){ for(int j=0;j&amp;lt;i;j++){ String suffix=s.substring(j,i); if(set.contains(suffix) &amp;amp;&amp;amp; dp[j]){ dp[i]=true; break; } } } return dp[s.length()]; }}Check out the description of this problem at LC 139." }, { "title" : "LeetCode 136.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-136.html", "date" : "January 11, 2024", "excerpt" : "package lc_136;public class Solution { public int singleNumber(int[] nums) { int ans = 0; for (int num: nums){ ans = ans ^ num; } return ans; }}Check out the description of this problem at LC 136.", "content" : "package lc_136;public class Solution { public int singleNumber(int[] nums) { int ans = 0; for (int num: nums){ ans = ans ^ num; } return ans; }}Check out the description of this problem at LC 136." }, { "title" : "LeetCode 1335.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1335.html", "date" : "January 11, 2024", "excerpt" : "package lc_1335;public class Solution { public int minDifficulty(int[] jobDifficulty, int d) { if (d &amp;amp;gt; jobDifficulty.length) return -1; int len = jobDifficulty.length; int[] left2right = new int[len]; int[] ri...", "content" : "package lc_1335;public class Solution { public int minDifficulty(int[] jobDifficulty, int d) { if (d &amp;gt; jobDifficulty.length) return -1; int len = jobDifficulty.length; int[] left2right = new int[len]; int[] right2left = new int[len]; int[] delta = new int[len]; left2right[0] = jobDifficulty[0]; right2left[0] = jobDifficulty[len - 1]; for (int i=1; i&amp;lt;len; i++){ left2right[i] = Math.max(left2right[i - 1], jobDifficulty[i]); right2left[len-1-i] = Math.max(left2right[len - i], jobDifficulty[len-1-i]); } for (int i=0; i&amp;lt;len; i++){ delta[i] = Math.abs(left2right[i] - right2left[i]); } boolean[] visited = new boolean[len]; int ans = 0; return ans; }}Check out the description of this problem at LC 1335." }, { "title" : "LeetCode 1318.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1318.html", "date" : "January 11, 2024", "excerpt" : "package lc_1318;public class Solution { public int minFlips(int a, int b, int c) { int count = 0; boolean a1 = false, b1 = false, c1 = false; while (a &amp;amp;gt; 0 || b &amp;amp;gt; 0 || c &amp;amp;gt; 0){ if (a % 2 == 1) ...", "content" : "package lc_1318;public class Solution { public int minFlips(int a, int b, int c) { int count = 0; boolean a1 = false, b1 = false, c1 = false; while (a &amp;gt; 0 || b &amp;gt; 0 || c &amp;gt; 0){ if (a % 2 == 1) a1 = true; if (b % 2 == 1) b1 = true; if (c % 2 == 1) c1 = true; if (c1 &amp;amp;&amp;amp; !(a1 || b1)){ count++; } if (!c1){ if (a1 &amp;amp;&amp;amp; b1) count += 2; else if (a1 || b1) count++; } a = a &amp;gt;&amp;gt; 1; b = b &amp;gt;&amp;gt; 1; c = c &amp;gt;&amp;gt; 1; a1 = false; b1 = false; c1 = false; } return count; }}Check out the description of this problem at LC 1318." }, { "title" : "LeetCode 131.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-131.html", "date" : "January 11, 2024", "excerpt" : "package lc_131;import java.util.ArrayList;import java.util.List;/** * Solution sol = new Solution(); * System.out.println(sol.partition(&amp;quot;aab&amp;quot;)); */public class Solution { List&amp;amp;lt;List&amp;amp;lt;String&amp;amp;gt;&amp;amp;gt; ...", "content" : "package lc_131;import java.util.ArrayList;import java.util.List;/** * Solution sol = new Solution(); * System.out.println(sol.partition(&quot;aab&quot;)); */public class Solution { List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;String&amp;gt; current = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) { recur(s, 0); return ans; } public void recur(String str, int start){ if (start &amp;gt;= str.length()){ ans.add(new ArrayList&amp;lt;&amp;gt;(current)); return; } for (int i=start; i&amp;lt;str.length(); i++){ if (isPalindrome(str, start, i)){ current.add(str.substring(start, i+1)); recur(str, i+1); current.remove(current.size()-1); } } } public boolean isPalindrome(String str, int low, int high){ while (low &amp;lt; high){ if (str.charAt(low++) != str.charAt(high--)) return false; } return true; }}Check out the description of this problem at LC 131." }, { "title" : "LeetCode 1268.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1268.html", "date" : "January 11, 2024", "excerpt" : "package lc_1268;import java.util.ArrayList;import java.util.List;import java.util.PriorityQueue;public class Solution { public List&amp;amp;lt;List&amp;amp;lt;String&amp;amp;gt;&amp;amp;gt; suggestedProducts(String[] products, String searchWord) { Prior...", "content" : "package lc_1268;import java.util.ArrayList;import java.util.List;import java.util.PriorityQueue;public class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; suggestedProducts(String[] products, String searchWord) { PriorityQueue&amp;lt;String&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(3, String::compareTo); List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); String temp; for (int i=1; i&amp;lt;=searchWord.length(); i++){ temp = searchWord.substring(0, i); for (String s: products){ if (s.startsWith(temp)){ queue.offer(s); } } List&amp;lt;String&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for (int j=0; j&amp;lt;3; j++){ if (queue.peek() != null){ tmp.add(queue.poll()); } } queue.clear(); ans.add(tmp); } return ans; }}Check out the description of this problem at LC 1268." }, { "title" : "LeetCode 123.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-123.html", "date" : "January 11, 2024", "excerpt" : "package lc_123;/** * @description: time exceeded */public class Solution {// public int maxProfit(int[] prices) {// if (prices.length &amp;amp;lt; 2) return 0;// int max = 0, len = prices.length;// for (int i = 1; i &amp;amp;lt;= l...", "content" : "package lc_123;/** * @description: time exceeded */public class Solution {// public int maxProfit(int[] prices) {// if (prices.length &amp;lt; 2) return 0;// int max = 0, len = prices.length;// for (int i = 1; i &amp;lt;= len - 1; i++){// max = Math.max(max, singleTransaction(0, i, prices) + singleTransaction(i, len-1, prices));// }// return max;// }// public int singleTransaction(int from, int to, int[] prices){// int min = Integer.MAX_VALUE;// int max = 0;// for (int i = from+1; i &amp;lt;= to; i++){// for (int j = i-1; j&amp;gt;=from; j--){// min = Math.min(min, prices[j]);// }// max = Math.max(max, prices[i] - min);// }// return max;// } public int maxProfit(int[] prices){ int buy1 = Integer.MAX_VALUE; int buy2 = Integer.MAX_VALUE; int sell1 = 0, sell2 = 0; for (int price: prices){ buy1 = Math.min(buy1, price); sell1 = Math.max(sell1, price - buy1); buy2 = Math.min(buy2, price - sell1); sell2 = Math.max(sell2, price - buy2); } return sell2; }}Check out the description of this problem at LC 123." }, { "title" : "LeetCode 122.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-122.html", "date" : "January 11, 2024", "excerpt" : "package lc_122;/** * int[] prices = new int[]{7,1,5,3,6,4}; * Solution sol = new Solution(); * System.out.println(sol.maxProfit(prices)); */public class Solution { public int maxProfit(int[] prices) { if (prices.l...", "content" : "package lc_122;/** * int[] prices = new int[]{7,1,5,3,6,4}; * Solution sol = new Solution(); * System.out.println(sol.maxProfit(prices)); */public class Solution { public int maxProfit(int[] prices) { if (prices.length == 1) return 0; int profits = 0; int min = Math.min(prices[0], prices[1]); if (prices[1] &amp;gt; prices[0]){ min = prices[1]; profits = prices[1] - prices[0]; } for (int i=2; i&amp;lt;prices.length; i++){ if (prices[i] &amp;gt; min){ profits += prices[i] - min; } min = prices[i]; } return profits; }}Check out the description of this problem at LC 122." }, { "title" : "LeetCode 1143.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1143.html", "date" : "January 11, 2024", "excerpt" : "package lc_1143;public class Solution {// public int longestCommonSubsequence(String text1, String text2) {// String lon = text1;// String shor = text2;// if (text2.length() &amp;amp;gt; text1.length()){// lon = text...", "content" : "package lc_1143;public class Solution {// public int longestCommonSubsequence(String text1, String text2) {// String lon = text1;// String shor = text2;// if (text2.length() &amp;gt; text1.length()){// lon = text2;// shor = text1;// }// return recur(lon.length() - 1, shor.length() - 1, lon, shor);// }//// public int recur(int current_l, int current_s, String lon, String shor){// if (current_l &amp;lt; 0 || current_s &amp;lt; 0) return 0;//// if (lon.substring(0, current_l + 1).contains(shor.substring(0, current_s + 1))) return current_s + 1;//// int ind_l = -1;//// for (int i=current_l; i&amp;gt;=0; i--){// if (shor.charAt(current_s) == lon.charAt(i)){// ind_l = i;// break;// }// }// if (ind_l &amp;gt;= 0){// return Math.max(recur(current_l, current_s-1, lon, shor),// recur(ind_l-1, current_s-1, lon, shor) + 1);// }// return Math.max(recur(current_l, current_s-1, lon, shor),// recur(ind_l, current_s-1, lon, shor));// } public int longestCommonSubsequence(String text1, String text2) { int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for (int i=1; i&amp;lt;=text1.length(); i++){ for (int j=1; j&amp;lt;=text2.length(); j++){ if (i == 1 &amp;amp;&amp;amp; j == 1) if (text1.charAt(0) == text2.charAt(0)) dp[1][1] = 1; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); if (text1.charAt(i-1) == text2.charAt(j-1)){ dp[i][j] = Math.max(dp[i-1][j-1] + 1, dp[i][j]); } } } return dp[text1.length()][text2.length()]; }}Check out the description of this problem at LC 1143." }, { "title" : "LeetCode 1137.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1137.html", "date" : "January 11, 2024", "excerpt" : "package lc_1137;public class Solution { public int tribonacci(int n) { int[] init = new int[]{0,1,1}; if (n &amp;amp;lt;= 2) return init[n]; int cur = 2, tmp = 0; while (n &amp;amp;gt; cur){ tmp = init[0] + init[1...", "content" : "package lc_1137;public class Solution { public int tribonacci(int n) { int[] init = new int[]{0,1,1}; if (n &amp;lt;= 2) return init[n]; int cur = 2, tmp = 0; while (n &amp;gt; cur){ tmp = init[0] + init[1] + init[2]; init[0] = init[1]; init[1] = init[2]; init[2] = tmp; cur++; } return init[2]; }}Check out the description of this problem at LC 1137." }, { "title" : "LeetCode 1071.", "category" : "", "tags" : " LeetCode", "url" : "/demo/2024/01/11/LeetCode-1071.html", "date" : "January 11, 2024", "excerpt" : "package lc_1071;public class Solution { public String gcdOfStrings(String str1, String str2) { // Check if concatenated strings are equal or not, if not return &amp;quot;&amp;quot; if (!(str1 + str2).equals(str2 + str1)) return...", "content" : "package lc_1071;public class Solution { public String gcdOfStrings(String str1, String str2) { // Check if concatenated strings are equal or not, if not return &quot;&quot; if (!(str1 + str2).equals(str2 + str1)) return &quot;&quot;; // If strings are equal than return the substring from 0 to gcd of size(str1), size(str2) int gcd = gcd(str1.length(), str2.length()); return str1.substring(0, gcd); } private int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }}Check out the description of this problem at LC 1071." } ,  { "title" : "About", "category" : "", "tags" : " Page", "url" : "/about/", "date" : "N/A", "excerpt" : "Type on Strap is based on Type Theme, a free and open-source theme for Jekyll, licensed under the MIT License.Head over to the theme’s documentation for much more information about Type on Strap or to install this theme on your own Jekyll site.Thi...", "content" : "Type on Strap is based on Type Theme, a free and open-source theme for Jekyll, licensed under the MIT License.Head over to the theme’s documentation for much more information about Type on Strap or to install this theme on your own Jekyll site.This file is an example of a page in Jekyll, that automatically shows up in the header navigation, you can delete or modify this file freely." },     { "title" : "Portfolio", "category" : "", "tags" : " Page", "url" : "/portfolio/", "date" : "N/A", "excerpt" : "", "content" : "" },   { "title" : "Tags", "category" : "", "tags" : " ", "url" : "/tags/", "date" : "N/A", "excerpt" : "", "content" : "" },                    { } ,{ "title" : "pentest_tls", "category" : "", "tags" : " Project", "url" : "/portfolio/pentls", "date" : "May 20, 2025", "excerpt" : "pentest_tlsMultiple lightweight pentest tools written in PythonInstallation Installed by pip/pip3 (recommended) pip install pentest-tls Usage Recommended to use with root privilegepentest_tls IP OPTIONS____ _ _ ...", "content" : "pentest_tlsMultiple lightweight pentest tools written in PythonInstallation Installed by pip/pip3 (recommended) pip install pentest-tls Usage Recommended to use with root privilegepentest_tls IP OPTIONS____ _ _ _____ _ | _ \\ ___ _ __ | |_ ___ ___| |_ |_ _|__ ___ | |___ | |_) / _ \\ &#39;_ \\| __/ _ \\/ __| __| | |/ _ \\ / _ \\| / __|| __/ __/ | | | || __/\\__ \\ |_ | | (_) | (_) | \\__ \\|_| \\___|_| |_|\\__\\___||___/\\__| |_|\\___/ \\___/|_|___/ usage: pentest_tls_cli.py [-h] [-t TYPE] [-p PORTS] [-PU] [-PS] [-PH] [-v] ipLightweight Pentest Toolkitpositional arguments: ip Target IP addressoptional arguments: -h, --help show this help message and exit -t TYPE, --type TYPE Tools refer to use. E.g. PS(for port scanner) -p PORTS, --ports PORTS Port(s) to scan. E.g. 22,80 or 1-1000 -PU Use UDP ping for port scan -PS Use TCP SYN packet for port scan. This is the default option -PH Hybrid, using udp and tcp scan -v Detailed information for query Basic Usagepentest_tls 127.0.0.1 -t PSpentest_tls 127.0.0.1 -t PS -p 80,443pentest_tls 127.0.0.1 -t PS -p 8000-8080pentest_tls 127.0.0.1 -t PS -p 80,443,8000-8080 Help Menu pentest_tls --helppentest_tls -h" } ]
